// Code generated by schema-generate. DO NOT EDIT.

package main

import (
    "bytes"
    "encoding/json"
    "errors"
)

// Root
type Root interface{}

// InitLandAttribution 
type InitLandAttribution struct {

  // 攻占的地块
  AttackLands map[string][]int `json:"attackLands"`

  // 购买的地块
  BuyLands map[string][]int `json:"buyLands"`

  // 消息版本号
  Etag int `json:"etag"`
}

// LandAttributionUpdate 
type LandAttributionUpdate struct {

  // 消息版本号
  Etag int `json:"etag"`

  // 消息版本号
  // 地块rc
  // R * 10000 + C
  TileId int `json:"tileId"`
  UserId string `json:"userId"`
}

// LandStatusUpdate 
type LandStatusUpdate struct {

  // 消息版本号
  Etag int `json:"etag"`

  // 状态
  Status string `json:"status"`

  // 地块rc
  TileId int `json:"tileId"`

  // 进攻地块的用户id
  UserId string `json:"userId"`
}

// MultiLandAttributionUpdate 
type MultiLandAttributionUpdate struct {

  // 消息版本号
  Etag int `json:"etag"`

  // 地块rc
  // R * 10000 + C
  TileId []int `json:"tileId"`
  UserId string `json:"userId"`
}

func (strct *InitLandAttribution) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AttackLands" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "attackLands" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"attackLands\": ")
	if tmp, err := json.Marshal(strct.AttackLands); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "BuyLands" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "buyLands" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"buyLands\": ")
	if tmp, err := json.Marshal(strct.BuyLands); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Etag" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "etag" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"etag\": ")
	if tmp, err := json.Marshal(strct.Etag); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InitLandAttribution) UnmarshalJSON(b []byte) error {
    attackLandsReceived := false
    buyLandsReceived := false
    etagReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "attackLands":
            if err := json.Unmarshal([]byte(v), &strct.AttackLands); err != nil {
                return err
             }
            attackLandsReceived = true
        case "buyLands":
            if err := json.Unmarshal([]byte(v), &strct.BuyLands); err != nil {
                return err
             }
            buyLandsReceived = true
        case "etag":
            if err := json.Unmarshal([]byte(v), &strct.Etag); err != nil {
                return err
             }
            etagReceived = true
        }
    }
    // check if attackLands (a required property) was received
    if !attackLandsReceived {
        return errors.New("\"attackLands\" is required but was not present")
    }
    // check if buyLands (a required property) was received
    if !buyLandsReceived {
        return errors.New("\"buyLands\" is required but was not present")
    }
    // check if etag (a required property) was received
    if !etagReceived {
        return errors.New("\"etag\" is required but was not present")
    }
    return nil
}

func (strct *LandAttributionUpdate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Etag" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "etag" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"etag\": ")
	if tmp, err := json.Marshal(strct.Etag); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TileId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tileId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tileId\": ")
	if tmp, err := json.Marshal(strct.TileId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "userId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"userId\": ")
	if tmp, err := json.Marshal(strct.UserId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LandAttributionUpdate) UnmarshalJSON(b []byte) error {
    etagReceived := false
    tileIdReceived := false
    userIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "etag":
            if err := json.Unmarshal([]byte(v), &strct.Etag); err != nil {
                return err
             }
            etagReceived = true
        case "tileId":
            if err := json.Unmarshal([]byte(v), &strct.TileId); err != nil {
                return err
             }
            tileIdReceived = true
        case "userId":
            if err := json.Unmarshal([]byte(v), &strct.UserId); err != nil {
                return err
             }
            userIdReceived = true
        }
    }
    // check if etag (a required property) was received
    if !etagReceived {
        return errors.New("\"etag\" is required but was not present")
    }
    // check if tileId (a required property) was received
    if !tileIdReceived {
        return errors.New("\"tileId\" is required but was not present")
    }
    // check if userId (a required property) was received
    if !userIdReceived {
        return errors.New("\"userId\" is required but was not present")
    }
    return nil
}

func (strct *LandStatusUpdate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Etag" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "etag" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"etag\": ")
	if tmp, err := json.Marshal(strct.Etag); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "status" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TileId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tileId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tileId\": ")
	if tmp, err := json.Marshal(strct.TileId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "userId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"userId\": ")
	if tmp, err := json.Marshal(strct.UserId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LandStatusUpdate) UnmarshalJSON(b []byte) error {
    etagReceived := false
    statusReceived := false
    tileIdReceived := false
    userIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "etag":
            if err := json.Unmarshal([]byte(v), &strct.Etag); err != nil {
                return err
             }
            etagReceived = true
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            statusReceived = true
        case "tileId":
            if err := json.Unmarshal([]byte(v), &strct.TileId); err != nil {
                return err
             }
            tileIdReceived = true
        case "userId":
            if err := json.Unmarshal([]byte(v), &strct.UserId); err != nil {
                return err
             }
            userIdReceived = true
        }
    }
    // check if etag (a required property) was received
    if !etagReceived {
        return errors.New("\"etag\" is required but was not present")
    }
    // check if status (a required property) was received
    if !statusReceived {
        return errors.New("\"status\" is required but was not present")
    }
    // check if tileId (a required property) was received
    if !tileIdReceived {
        return errors.New("\"tileId\" is required but was not present")
    }
    // check if userId (a required property) was received
    if !userIdReceived {
        return errors.New("\"userId\" is required but was not present")
    }
    return nil
}

func (strct *MultiLandAttributionUpdate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Etag" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "etag" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"etag\": ")
	if tmp, err := json.Marshal(strct.Etag); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TileId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tileId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tileId\": ")
	if tmp, err := json.Marshal(strct.TileId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "UserId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "userId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"userId\": ")
	if tmp, err := json.Marshal(strct.UserId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MultiLandAttributionUpdate) UnmarshalJSON(b []byte) error {
    etagReceived := false
    tileIdReceived := false
    userIdReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "etag":
            if err := json.Unmarshal([]byte(v), &strct.Etag); err != nil {
                return err
             }
            etagReceived = true
        case "tileId":
            if err := json.Unmarshal([]byte(v), &strct.TileId); err != nil {
                return err
             }
            tileIdReceived = true
        case "userId":
            if err := json.Unmarshal([]byte(v), &strct.UserId); err != nil {
                return err
             }
            userIdReceived = true
        }
    }
    // check if etag (a required property) was received
    if !etagReceived {
        return errors.New("\"etag\" is required but was not present")
    }
    // check if tileId (a required property) was received
    if !tileIdReceived {
        return errors.New("\"tileId\" is required but was not present")
    }
    // check if userId (a required property) was received
    if !userIdReceived {
        return errors.New("\"userId\" is required but was not present")
    }
    return nil
}
