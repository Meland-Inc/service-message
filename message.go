// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "fmt"
import "reflect"
import "encoding/json"

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType_1, v)
	}
	*j = UserType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserPlaceablesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["placeables"]; !ok || v == nil {
		return fmt.Errorf("field placeables: required")
	}
	if v, ok := raw["thirdInfo"]; !ok || v == nil {
		return fmt.Errorf("field thirdInfo: required")
	}
	if v, ok := raw["thirdTimeOut"]; !ok || v == nil {
		return fmt.Errorf("field thirdTimeOut: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UserPlaceablesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserPlaceablesOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlaceableRarity_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PlaceableRarity_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PlaceableRarity_1, v)
	}
	*j = PlaceableRarity_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserPlaceablesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UserPlaceablesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserPlaceablesInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserGameDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UserGameDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserGameDataOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserGameDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UserGameDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserGameDataInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *User) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatar"]; !ok || v == nil {
		return fmt.Errorf("field avatar: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["mobile"]; !ok || v == nil {
		return fmt.Errorf("field mobile: required")
	}
	if v, ok := raw["nickname"]; !ok || v == nil {
		return fmt.Errorf("field nickname: required")
	}
	if v, ok := raw["realname"]; !ok || v == nil {
		return fmt.Errorf("field realname: required")
	}
	if v, ok := raw["schoolId"]; !ok || v == nil {
		return fmt.Errorf("field schoolId: required")
	}
	if v, ok := raw["sex"]; !ok || v == nil {
		return fmt.Errorf("field sex: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username: required")
	}
	if v, ok := raw["usertype"]; !ok || v == nil {
		return fmt.Errorf("field usertype: required")
	}
	type Plain User
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = User(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType, v)
	}
	*j = UserType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex_1, v)
	}
	*j = Sex_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlaceableSkill) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["skillId"]; !ok || v == nil {
		return fmt.Errorf("field skillId: required")
	}
	type Plain PlaceableSkill
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlaceableSkill(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateThirdNftTimeOut) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["timeOutSec"]; !ok || v == nil {
		return fmt.Errorf("field timeOutSec: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UpdateThirdNftTimeOut
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpdateThirdNftTimeOut(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Placeable) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["objectId"]; !ok || v == nil {
		return fmt.Errorf("field objectId: required")
	}
	if v, ok := raw["placeableId"]; !ok || v == nil {
		return fmt.Errorf("field placeableId: required")
	}
	if v, ok := raw["placeableLand"]; !ok || v == nil {
		return fmt.Errorf("field placeableLand: required")
	}
	if v, ok := raw["rarity"]; !ok || v == nil {
		return fmt.Errorf("field rarity: required")
	}
	if v, ok := raw["skillList"]; !ok || v == nil {
		return fmt.Errorf("field skillList: required")
	}
	type Plain Placeable
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Placeable(plain)
	return nil
}

type AddPlaceable struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// 道具信息
	Placeables Placeable `json:"placeables"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AddPlaceable) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["placeables"]; !ok || v == nil {
		return fmt.Errorf("field placeables: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain AddPlaceable
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AddPlaceable(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThirdNftTimeOut) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["timeOutSec"]; !ok || v == nil {
		return fmt.Errorf("field timeOutSec: required")
	}
	type Plain ThirdNftTimeOut
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ThirdNftTimeOut(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThirdNft) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["desc"]; !ok || v == nil {
		return fmt.Errorf("field desc: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["resUrl"]; !ok || v == nil {
		return fmt.Errorf("field resUrl: required")
	}
	type Plain ThirdNft
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ThirdNft(plain)
	return nil
}

type AddThirdNft struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// 道具信息
	ThirdNft ThirdNft `json:"thirdNft"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AddThirdNft) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["thirdNft"]; !ok || v == nil {
		return fmt.Errorf("field thirdNft: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain AddThirdNft
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AddThirdNft(plain)
	return nil
}

type AuthUserType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["createdAt"]; !ok || v == nil {
		return fmt.Errorf("field createdAt: required")
	}
	if v, ok := raw["expiredAt"]; !ok || v == nil {
		return fmt.Errorf("field expiredAt: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["token"]; !ok || v == nil {
		return fmt.Errorf("field token: required")
	}
	if v, ok := raw["updatedAt"]; !ok || v == nil {
		return fmt.Errorf("field updatedAt: required")
	}
	type Plain TemporaryToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryToken(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthUserType, v)
	}
	*j = AuthUserType(v)
	return nil
}

const AuthUserTypeMANAGER AuthUserType = "MANAGER"
const AuthUserTypeSTUDENT AuthUserType = "STUDENT"
const AuthUserTypeTEACHER AuthUserType = "TEACHER"

type Auth struct {
	// AccessToken corresponds to the JSON schema field "accessToken".
	AccessToken string `json:"accessToken"`

	// UserType corresponds to the JSON schema field "userType".
	UserType *AuthUserType `json:"userType,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Auth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["accessToken"]; !ok || v == nil {
		return fmt.Errorf("field accessToken: required")
	}
	type Plain Auth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Auth(plain)
	return nil
}

type Class struct {
	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt string `json:"createdAt"`

	// CreatorId corresponds to the JSON schema field "creatorId".
	CreatorId string `json:"creatorId"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`

	// SchoolId corresponds to the JSON schema field "schoolId".
	SchoolId string `json:"schoolId"`

	// Status corresponds to the JSON schema field "status".
	Status float64 `json:"status"`

	// StudentCount corresponds to the JSON schema field "studentCount".
	StudentCount float64 `json:"studentCount"`

	// UpdateAt corresponds to the JSON schema field "updateAt".
	UpdateAt string `json:"updateAt"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Class) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["createdAt"]; !ok || v == nil {
		return fmt.Errorf("field createdAt: required")
	}
	if v, ok := raw["creatorId"]; !ok || v == nil {
		return fmt.Errorf("field creatorId: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["schoolId"]; !ok || v == nil {
		return fmt.Errorf("field schoolId: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	if v, ok := raw["studentCount"]; !ok || v == nil {
		return fmt.Errorf("field studentCount: required")
	}
	if v, ok := raw["updateAt"]; !ok || v == nil {
		return fmt.Errorf("field updateAt: required")
	}
	type Plain Class
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Class(plain)
	return nil
}

type ClassCourse struct {
	// CompletedCover corresponds to the JSON schema field "completedCover".
	CompletedCover string `json:"completedCover"`

	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatorId corresponds to the JSON schema field "creatorId".
	CreatorId string `json:"creatorId"`

	// Description corresponds to the JSON schema field "description".
	Description string `json:"description"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Index corresponds to the JSON schema field "index".
	Index float64 `json:"index"`

	// MapId corresponds to the JSON schema field "mapId".
	MapId string `json:"mapId"`

	// MapType corresponds to the JSON schema field "mapType".
	MapType string `json:"mapType"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`

	// NoStartedCover corresponds to the JSON schema field "noStartedCover".
	NoStartedCover string `json:"noStartedCover"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark"`

	// StartedCover corresponds to the JSON schema field "startedCover".
	StartedCover string `json:"startedCover"`

	// TeacherSuggest corresponds to the JSON schema field "teacherSuggest".
	TeacherSuggest string `json:"teacherSuggest"`

	// UpdatedAt corresponds to the JSON schema field "updatedAt".
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ClassCourse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["completedCover"]; !ok || v == nil {
		return fmt.Errorf("field completedCover: required")
	}
	if v, ok := raw["creatorId"]; !ok || v == nil {
		return fmt.Errorf("field creatorId: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId: required")
	}
	if v, ok := raw["mapType"]; !ok || v == nil {
		return fmt.Errorf("field mapType: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["noStartedCover"]; !ok || v == nil {
		return fmt.Errorf("field noStartedCover: required")
	}
	if v, ok := raw["remark"]; !ok || v == nil {
		return fmt.Errorf("field remark: required")
	}
	if v, ok := raw["startedCover"]; !ok || v == nil {
		return fmt.Errorf("field startedCover: required")
	}
	if v, ok := raw["teacherSuggest"]; !ok || v == nil {
		return fmt.Errorf("field teacherSuggest: required")
	}
	type Plain ClassCourse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ClassCourse(plain)
	return nil
}

type CourseBrief struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Index corresponds to the JSON schema field "index".
	Index *float64 `json:"index,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CourseBrief) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain CourseBrief
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CourseBrief(plain)
	return nil
}

type CoursePackageLocked float64

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryTokenExtraInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain TemporaryTokenExtraInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryTokenExtraInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoursePackageLocked) UnmarshalJSON(b []byte) error {
	var v float64
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CoursePackageLocked {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CoursePackageLocked, v)
	}
	*j = CoursePackageLocked(v)
	return nil
}

type CoursePackage struct {
	// CoursePackageTypeId corresponds to the JSON schema field "coursePackageTypeId".
	CoursePackageTypeId string `json:"coursePackageTypeId"`

	// Courses corresponds to the JSON schema field "courses".
	Courses []CourseBrief `json:"courses,omitempty"`

	// Cover corresponds to the JSON schema field "cover".
	Cover string `json:"cover"`

	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt string `json:"createdAt"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Introduce corresponds to the JSON schema field "introduce".
	Introduce string `json:"introduce"`

	// Level corresponds to the JSON schema field "level".
	Level string `json:"level"`

	// Locked corresponds to the JSON schema field "locked".
	Locked CoursePackageLocked `json:"locked"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark"`

	// Tags corresponds to the JSON schema field "tags".
	Tags string `json:"tags"`

	// UpdatedAt corresponds to the JSON schema field "updatedAt".
	UpdatedAt string `json:"updatedAt"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoursePackage) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["coursePackageTypeId"]; !ok || v == nil {
		return fmt.Errorf("field coursePackageTypeId: required")
	}
	if v, ok := raw["cover"]; !ok || v == nil {
		return fmt.Errorf("field cover: required")
	}
	if v, ok := raw["createdAt"]; !ok || v == nil {
		return fmt.Errorf("field createdAt: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["introduce"]; !ok || v == nil {
		return fmt.Errorf("field introduce: required")
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["locked"]; !ok || v == nil {
		return fmt.Errorf("field locked: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["remark"]; !ok || v == nil {
		return fmt.Errorf("field remark: required")
	}
	if v, ok := raw["tags"]; !ok || v == nil {
		return fmt.Errorf("field tags: required")
	}
	if v, ok := raw["updatedAt"]; !ok || v == nil {
		return fmt.Errorf("field updatedAt: required")
	}
	type Plain CoursePackage
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoursePackage(plain)
	return nil
}

type DeleteNft struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// Nft Id
	NftId string `json:"nftId"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeleteNft) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain DeleteNft
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DeleteNft(plain)
	return nil
}

type Int32 int

// UnmarshalJSON implements json.Unmarshaler.
func (j *TeacherCertificate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["certificateId"]; !ok || v == nil {
		return fmt.Errorf("field certificateId: required")
	}
	if v, ok := raw["createdAt"]; !ok || v == nil {
		return fmt.Errorf("field createdAt: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain TeacherCertificate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TeacherCertificate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserLandInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["occupiedLands"]; !ok || v == nil {
		return fmt.Errorf("field occupiedLands: required")
	}
	if v, ok := raw["ticketLands"]; !ok || v == nil {
		return fmt.Errorf("field ticketLands: required")
	}
	if v, ok := raw["vipLands"]; !ok || v == nil {
		return fmt.Errorf("field vipLands: required")
	}
	type Plain UserLandInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserLandInfo(plain)
	return nil
}

// 玩家地格信息 userId = UserLandInfo
type InitLandAttributionLandInfos map[string]UserLandInfo

type InitLandAttribution struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// 玩家地格信息 userId = UserLandInfo
	LandInfos InitLandAttributionLandInfos `json:"landInfos"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InitLandAttribution) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landInfos"]; !ok || v == nil {
		return fmt.Errorf("field landInfos: required")
	}
	type Plain InitLandAttribution
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = InitLandAttribution(plain)
	return nil
}

type LandStatus string

// UnmarshalJSON implements json.Unmarshaler.
func (j *StudentJoinClass) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["classId"]; !ok || v == nil {
		return fmt.Errorf("field classId: required")
	}
	type Plain StudentJoinClass
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StudentJoinClass(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandStatus, v)
	}
	*j = LandStatus(v)
	return nil
}

const LandStatusNill LandStatus = "nill"
const LandStatusOccupied LandStatus = "occupied"
const LandStatusTicket LandStatus = "ticket"
const LandStatusUnoccupied LandStatus = "unoccupied"
const LandStatusVip LandStatus = "vip"

type LandAttributionUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// landId = 地格坐标R*10000 + 地格坐标C
	LandId Int32 `json:"landId"`

	// 地格新的归属状态
	// unoccupied || occupied || ticket || vip
	LandStatus LandStatus `json:"landStatus"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandAttributionUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["landStatus"]; !ok || v == nil {
		return fmt.Errorf("field landStatus: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandAttributionUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandAttributionUpdate(plain)
	return nil
}

type LandFightStatus string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex, v)
	}
	*j = Sex(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandFightStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandFightStatus, v)
	}
	*j = LandFightStatus(v)
	return nil
}

const LandFightStatusAttacked LandFightStatus = "attacked"
const LandFightStatusNormal LandFightStatus = "normal"

type LandFightStatus_1 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *School) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["addressLocation"]; !ok || v == nil {
		return fmt.Errorf("field addressLocation: required")
	}
	if v, ok := raw["areaCode"]; !ok || v == nil {
		return fmt.Errorf("field areaCode: required")
	}
	if v, ok := raw["brandId"]; !ok || v == nil {
		return fmt.Errorf("field brandId: required")
	}
	if v, ok := raw["cityCode"]; !ok || v == nil {
		return fmt.Errorf("field cityCode: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["provinceCode"]; !ok || v == nil {
		return fmt.Errorf("field provinceCode: required")
	}
	type Plain School
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = School(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatus_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandFightStatus_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandFightStatus_1, v)
	}
	*j = LandFightStatus_1(v)
	return nil
}

const LandFightStatus_1_Attacked LandFightStatus_1 = "attacked"
const LandFightStatus_1_Normal LandFightStatus_1 = "normal"

type LandFightStatusUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// 状态 attacked || normal
	FightStatus LandFightStatus_1 `json:"fightStatus"`

	// landId = 地格坐标R*10000 + 地格坐标C
	LandId Int32 `json:"landId"`

	// 进攻地块的用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatusUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["fightStatus"]; !ok || v == nil {
		return fmt.Errorf("field fightStatus: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandFightStatusUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandFightStatusUpdate(plain)
	return nil
}

type LandStatus_1 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlaceableRarity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PlaceableRarity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PlaceableRarity, v)
	}
	*j = PlaceableRarity(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandStatus_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandStatus_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandStatus_1, v)
	}
	*j = LandStatus_1(v)
	return nil
}

type Int321 int

// UnmarshalJSON implements json.Unmarshaler.
func (j *PageMeta) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		return fmt.Errorf("field count: required")
	}
	type Plain PageMeta
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PageMeta(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NftCanBuildOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["canBuild"]; !ok || v == nil {
		return fmt.Errorf("field canBuild: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	type Plain NftCanBuildOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NftCanBuildOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NftCanBuildInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["aliveTimeSec"]; !ok || v == nil {
		return fmt.Errorf("field aliveTimeSec: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain NftCanBuildInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NftCanBuildInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiLandAttributionUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["occupiedLandIds"]; !ok || v == nil {
		return fmt.Errorf("field occupiedLandIds: required")
	}
	if v, ok := raw["ticketLandIds"]; !ok || v == nil {
		return fmt.Errorf("field ticketLandIds: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	if v, ok := raw["vipLandIds"]; !ok || v == nil {
		return fmt.Errorf("field vipLandIds: required")
	}
	type Plain MultiLandAttributionUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiLandAttributionUpdate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["skillList"]; !ok || v == nil {
		return fmt.Errorf("field skillList: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillOutput(plain)
	return nil
}

const LandStatus_1_Nill LandStatus_1 = "nill"
const LandStatus_1_Occupied LandStatus_1 = "occupied"
const LandStatus_1_Ticket LandStatus_1 = "ticket"
const LandStatus_1_Unoccupied LandStatus_1 = "unoccupied"
const LandStatus_1_Vip LandStatus_1 = "vip"

type LandUsingSkillInput struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// 地格ID
	TileId Int321 `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

type LandUsingSkillOutput struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// skill list
	SkillList []PlaceableSkill `json:"skillList"`

	// 地格ID
	TileId Int321 `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

type MultiLandAttributionUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// OccupiedLandIds corresponds to the JSON schema field "occupiedLandIds".
	OccupiedLandIds []Int32 `json:"occupiedLandIds"`

	// TicketLandIds corresponds to the JSON schema field "ticketLandIds".
	TicketLandIds []Int32 `json:"ticketLandIds"`

	// 归属用户id
	UserId string `json:"userId"`

	// landId = 地格坐标R*10000 + 地格坐标C
	VipLandIds []Int32 `json:"vipLandIds"`
}

type NftCanBuildInput struct {
	// 实体存活时间，对第三方NFT有效, 单位(秒)
	AliveTimeSec Int321 `json:"aliveTimeSec"`

	// Nft Id
	NftId string `json:"nftId"`

	// 归属用户id
	UserId string `json:"userId"`
}

type NftCanBuildOutput struct {
	// CanBuild corresponds to the JSON schema field "canBuild".
	CanBuild bool `json:"canBuild"`

	// 消息版本号
	Etag Int321 `json:"etag"`

	// Nft Id
	NftId string `json:"nftId"`
}

type PageMeta struct {
	// Count corresponds to the JSON schema field "count".
	Count float64 `json:"count"`
}

// 道具信息数据结构
type Placeable struct {
	// object config Id
	ObjectId Int321 `json:"objectId"`

	// Nft Id
	PlaceableId string `json:"placeableId"`

	// can build land
	PlaceableLand []string `json:"placeableLand"`

	// Placeable Rarity
	Rarity PlaceableRarity_1 `json:"rarity"`

	// skill list
	SkillList []PlaceableSkill `json:"skillList"`
}

type PlaceableRarity string

const PlaceableRarityCommon PlaceableRarity = "common"
const PlaceableRarityEpic PlaceableRarity = "epic"
const PlaceableRarityMythic PlaceableRarity = "mythic"
const PlaceableRarityRare PlaceableRarity = "rare"
const PlaceableRarityUnique PlaceableRarity = "unique"

type PlaceableRarity_1 string

const PlaceableRarity_1_Common PlaceableRarity_1 = "common"
const PlaceableRarity_1_Epic PlaceableRarity_1 = "epic"
const PlaceableRarity_1_Mythic PlaceableRarity_1 = "mythic"
const PlaceableRarity_1_Rare PlaceableRarity_1 = "rare"
const PlaceableRarity_1_Unique PlaceableRarity_1 = "unique"

type PlaceableSkill struct {
	// skill level
	Level Int321 `json:"level"`

	// skill Id,  only key
	SkillId Int321 `json:"skillId"`
}

type School struct {
	// AddressLocation corresponds to the JSON schema field "addressLocation".
	AddressLocation string `json:"addressLocation"`

	// AreaCode corresponds to the JSON schema field "areaCode".
	AreaCode string `json:"areaCode"`

	// BrandId corresponds to the JSON schema field "brandId".
	BrandId string `json:"brandId"`

	// CityCode corresponds to the JSON schema field "cityCode".
	CityCode string `json:"cityCode"`

	// CoursePackages corresponds to the JSON schema field "coursePackages".
	CoursePackages []string `json:"coursePackages,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`

	// ProvinceCode corresponds to the JSON schema field "provinceCode".
	ProvinceCode string `json:"provinceCode"`
}

type Sex string

const SexFEMALE Sex = "FEMALE"
const SexMALE Sex = "MALE"

type Sex_1 string

const Sex_1_FEMALE Sex_1 = "FEMALE"
const Sex_1_MALE Sex_1 = "MALE"

type StudentJoinClass struct {
	// ClassId corresponds to the JSON schema field "classId".
	ClassId string `json:"classId"`
}

type TeacherCertificate struct {
	// CertificateId corresponds to the JSON schema field "certificateId".
	CertificateId string `json:"certificateId"`

	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt string `json:"createdAt"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type TemporaryToken struct {
	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt string `json:"createdAt"`

	// ExpiredAt corresponds to the JSON schema field "expiredAt".
	ExpiredAt string `json:"expiredAt"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// TemporaryTokenExtraInfo corresponds to the JSON schema field
	// "temporaryTokenExtraInfo".
	TemporaryTokenExtraInfo *TemporaryTokenExtraInfo `json:"temporaryTokenExtraInfo,omitempty"`

	// Token corresponds to the JSON schema field "token".
	Token string `json:"token"`

	// UpdatedAt corresponds to the JSON schema field "updatedAt".
	UpdatedAt string `json:"updatedAt"`

	// UsedAt corresponds to the JSON schema field "usedAt".
	UsedAt *string `json:"usedAt,omitempty"`
}

type TemporaryTokenExtraInfo struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// 第三方NFT信息结构
type ThirdNft struct {
	// 描述信息，
	Desc string `json:"desc"`

	// 名字（是否唯一）
	Name string `json:"name"`

	// Nft Id
	NftId string `json:"nftId"`

	// 展示图片
	ResUrl string `json:"resUrl"`
}

// 第三方NFT信息结构
type ThirdNftTimeOut struct {
	// Nft Id
	NftId string `json:"nftId"`

	// 名字（是否唯一）
	TimeOutSec Int321 `json:"timeOutSec"`
}

// 更新 第三方NFT   建造过期时间
type UpdateThirdNftTimeOut struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// Nft Id
	NftId string `json:"nftId"`

	// 过期时间 单位 秒， 清空则给0
	TimeOutSec Int321 `json:"timeOutSec"`

	// 归属用户id
	UserId string `json:"userId"`
}

type User struct {
	// Avatar corresponds to the JSON schema field "avatar".
	Avatar string `json:"avatar"`

	// Email corresponds to the JSON schema field "email".
	Email string `json:"email"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Mobile corresponds to the JSON schema field "mobile".
	Mobile string `json:"mobile"`

	// Nickname corresponds to the JSON schema field "nickname".
	Nickname string `json:"nickname"`

	// Realname corresponds to the JSON schema field "realname".
	Realname string `json:"realname"`

	// SchoolId corresponds to the JSON schema field "schoolId".
	SchoolId string `json:"schoolId"`

	// Sex corresponds to the JSON schema field "sex".
	Sex Sex_1 `json:"sex"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username"`

	// Usertype corresponds to the JSON schema field "usertype".
	Usertype UserType `json:"usertype"`
}

type UserGameDataInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type UserGameDataOutput struct {
	// game name
	Name string `json:"name"`

	// 游戏角色ID
	PlayerId string `json:"playerId"`

	// user id
	UserId string `json:"userId"`
}

// 玩家地格信息数据结构
type UserLandInfo struct {
	// 攻占的地格
	OccupiedLands []Int32 `json:"occupiedLands"`

	// 门票地格
	TicketLands []Int32 `json:"ticketLands"`

	// 购买的地格
	VipLands []Int32 `json:"vipLands"`
}

// 玩家所有的道具信息 请求消息结构
type UserPlaceablesInput struct {
	// 归属用户id
	UserId string `json:"userId"`
}

// 玩家所有的道具信息 返回消息结构
type UserPlaceablesOutput struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// 玩家放置道具信息 Placeable[]
	Placeables []Placeable `json:"placeables"`

	// 第三方NFT LIST
	ThirdInfo []ThirdNft `json:"thirdInfo"`

	// 第三方NFT 放置后的过期时间列表
	ThirdTimeOut []ThirdNftTimeOut `json:"thirdTimeOut"`

	// 归属用户id
	UserId string `json:"userId"`
}

type UserType string

const UserTypeMANAGER UserType = "MANAGER"
const UserTypeSTUDENT UserType = "STUDENT"
const UserTypeTEACHER UserType = "TEACHER"

type UserType_1 string

const UserType_1_MANAGER UserType_1 = "MANAGER"
const UserType_1_STUDENT UserType_1 = "STUDENT"
const UserType_1_TEACHER UserType_1 = "TEACHER"

var enumValues_AuthUserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_CoursePackageLocked = []interface{}{
	0,
	1,
}
var enumValues_LandFightStatus = []interface{}{
	"attacked",
	"normal",
}
var enumValues_LandFightStatus_1 = []interface{}{
	"attacked",
	"normal",
}
var enumValues_LandStatus = []interface{}{
	"nill",
	"occupied",
	"ticket",
	"unoccupied",
	"vip",
}
var enumValues_LandStatus_1 = []interface{}{
	"nill",
	"occupied",
	"ticket",
	"unoccupied",
	"vip",
}
var enumValues_PlaceableRarity = []interface{}{
	"common",
	"epic",
	"mythic",
	"rare",
	"unique",
}
var enumValues_PlaceableRarity_1 = []interface{}{
	"common",
	"epic",
	"mythic",
	"rare",
	"unique",
}
var enumValues_Sex = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_Sex_1 = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_UserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_UserType_1 = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
