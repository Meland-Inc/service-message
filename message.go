// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "fmt"
import "encoding/json"
import "reflect"

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatusUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["fightStatus"]; !ok || v == nil {
		return fmt.Errorf("field fightStatus: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandFightStatusUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandFightStatusUpdate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Web3ServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Web3ServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Web3ServiceAction, v)
	}
	*j = Web3ServiceAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTAttribute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trait_type"]; !ok || v == nil {
		return fmt.Errorf("field trait_type: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain NFTAttribute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTAttribute(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType_1, v)
	}
	*j = UserType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTMetadata_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["attributes"]; !ok || v == nil {
		return fmt.Errorf("field attributes: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain NFTMetadata_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTMetadata_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserGameDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UserGameDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserGameDataOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["isMelandAI"]; !ok || v == nil {
		return fmt.Errorf("field isMelandAI: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata: required")
	}
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId: required")
	}
	if v, ok := raw["tokenURL"]; !ok || v == nil {
		return fmt.Errorf("field tokenURL: required")
	}
	type Plain NFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFT(plain)
	return nil
}

// 添加一个NFT
type AddUserNFT struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// 装备信息
	Nft NFT `json:"nft"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AddUserNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nft"]; !ok || v == nil {
		return fmt.Errorf("field nft: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain AddUserNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AddUserNFT(plain)
	return nil
}

type AppId string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserGameDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UserGameDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserGameDataInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppId) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppId {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppId, v)
	}
	*j = AppId(v)
	return nil
}

const AppIdBellplanetGame AppId = "bellplanet-game"
const AppIdMelandService AppId = "meland-service"
const AppIdWeb3Service AppId = "web3-service"

type AuthUserType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *User) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatar"]; !ok || v == nil {
		return fmt.Errorf("field avatar: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["mobile"]; !ok || v == nil {
		return fmt.Errorf("field mobile: required")
	}
	if v, ok := raw["nickname"]; !ok || v == nil {
		return fmt.Errorf("field nickname: required")
	}
	if v, ok := raw["realname"]; !ok || v == nil {
		return fmt.Errorf("field realname: required")
	}
	if v, ok := raw["schoolId"]; !ok || v == nil {
		return fmt.Errorf("field schoolId: required")
	}
	if v, ok := raw["sex"]; !ok || v == nil {
		return fmt.Errorf("field sex: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username: required")
	}
	if v, ok := raw["usertype"]; !ok || v == nil {
		return fmt.Errorf("field usertype: required")
	}
	type Plain User
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = User(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthUserType, v)
	}
	*j = AuthUserType(v)
	return nil
}

const AuthUserTypeMANAGER AuthUserType = "MANAGER"
const AuthUserTypeSTUDENT AuthUserType = "STUDENT"
const AuthUserTypeTEACHER AuthUserType = "TEACHER"

type Auth struct {
	// AccessToken corresponds to the JSON schema field "accessToken".
	AccessToken string `json:"accessToken"`

	// UserType corresponds to the JSON schema field "userType".
	UserType *AuthUserType `json:"userType,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Auth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["accessToken"]; !ok || v == nil {
		return fmt.Errorf("field accessToken: required")
	}
	type Plain Auth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Auth(plain)
	return nil
}

type CanBuildNFTInput struct {
	// 实体存活时间，对第三方NFT有效, 单位(秒)
	AliveTimeSec Int321 `json:"aliveTimeSec"`

	// Nft Id
	NftId string `json:"nftId"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["aliveTimeSec"]; !ok || v == nil {
		return fmt.Errorf("field aliveTimeSec: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain CanBuildNFTInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTInput(plain)
	return nil
}

type CanBuildNFTOutput struct {
	// CanBuild corresponds to the JSON schema field "canBuild".
	CanBuild bool `json:"canBuild"`

	// 消息版本号
	Etag Int321 `json:"etag"`

	// NFT id
	NftId string `json:"nftId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["canBuild"]; !ok || v == nil {
		return fmt.Errorf("field canBuild: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	type Plain CanBuildNFTOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTOutput(plain)
	return nil
}

// 删除NFT
type DeleteUserNFT struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// NFT id
	NftId string `json:"nftId"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeleteUserNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain DeleteUserNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DeleteUserNFT(plain)
	return nil
}

type GameServiceAction string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType, v)
	}
	*j = UserType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GameServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GameServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GameServiceAction, v)
	}
	*j = GameServiceAction(v)
	return nil
}

const GameServiceActionLandUsingSkill GameServiceAction = "LandUsingSkill"

type GetUserNFTsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserNFTsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex_1, v)
	}
	*j = Sex_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTPlaceableTimeout) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["timeoutSec"]; !ok || v == nil {
		return fmt.Errorf("field timeoutSec: required")
	}
	type Plain NFTPlaceableTimeout
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTPlaceableTimeout(plain)
	return nil
}

type GetUserNFTsOutput struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// user all nfts
	Nfts []NFT `json:"nfts"`

	// NFT放置过期时间表
	PlaceableTimeouts []NFTPlaceableTimeout `json:"placeableTimeouts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts: required")
	}
	if v, ok := raw["placeableTimeouts"]; !ok || v == nil {
		return fmt.Errorf("field placeableTimeouts: required")
	}
	type Plain GetUserNFTsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsOutput(plain)
	return nil
}

type Int32 int

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["createdAt"]; !ok || v == nil {
		return fmt.Errorf("field createdAt: required")
	}
	if v, ok := raw["expiredAt"]; !ok || v == nil {
		return fmt.Errorf("field expiredAt: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["token"]; !ok || v == nil {
		return fmt.Errorf("field token: required")
	}
	if v, ok := raw["updatedAt"]; !ok || v == nil {
		return fmt.Errorf("field updatedAt: required")
	}
	type Plain TemporaryToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryToken(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserLandInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["occupiedLands"]; !ok || v == nil {
		return fmt.Errorf("field occupiedLands: required")
	}
	if v, ok := raw["ticketLands"]; !ok || v == nil {
		return fmt.Errorf("field ticketLands: required")
	}
	if v, ok := raw["vipLands"]; !ok || v == nil {
		return fmt.Errorf("field vipLands: required")
	}
	type Plain UserLandInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserLandInfo(plain)
	return nil
}

// 玩家地格信息 userId = UserLandInfo
type InitLandAttributionLandInfos map[string]UserLandInfo

type InitLandAttribution struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// 玩家地格信息 userId = UserLandInfo
	LandInfos InitLandAttributionLandInfos `json:"landInfos"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InitLandAttribution) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landInfos"]; !ok || v == nil {
		return fmt.Errorf("field landInfos: required")
	}
	type Plain InitLandAttribution
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = InitLandAttribution(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryTokenExtraInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain TemporaryTokenExtraInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryTokenExtraInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionEvent) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubscriptionEvent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubscriptionEvent, v)
	}
	*j = SubscriptionEvent(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex, v)
	}
	*j = Sex(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandStatus, v)
	}
	*j = LandStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PageMeta) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		return fmt.Errorf("field count: required")
	}
	type Plain PageMeta
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PageMeta(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitType, v)
	}
	*j = NFTTraitType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitRarity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitRarity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitRarity, v)
	}
	*j = NFTTraitRarity(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitPlaceableLands) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitPlaceableLands {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitPlaceableLands, v)
	}
	*j = NFTTraitPlaceableLands(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitTypes, v)
	}
	*j = NFTTraitTypes(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiLandAttributionUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["occupiedLandIds"]; !ok || v == nil {
		return fmt.Errorf("field occupiedLandIds: required")
	}
	if v, ok := raw["ticketLandIds"]; !ok || v == nil {
		return fmt.Errorf("field ticketLandIds: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	if v, ok := raw["vipLandIds"]; !ok || v == nil {
		return fmt.Errorf("field vipLandIds: required")
	}
	type Plain MultiLandAttributionUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiLandAttributionUpdate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandAttributionUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["landStatus"]; !ok || v == nil {
		return fmt.Errorf("field landStatus: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandAttributionUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandAttributionUpdate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithMetadataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain MintNFTWithMetadataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithMetadataOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithMetadataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata: required")
	}
	if v, ok := raw["mintCount"]; !ok || v == nil {
		return fmt.Errorf("field mintCount: required")
	}
	if v, ok := raw["toUserId"]; !ok || v == nil {
		return fmt.Errorf("field toUserId: required")
	}
	type Plain MintNFTWithMetadataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithMetadataInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandFightStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandFightStatus, v)
	}
	*j = LandFightStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain MintNFTWithItemIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["mintCount"]; !ok || v == nil {
		return fmt.Errorf("field mintCount: required")
	}
	if v, ok := raw["toUserId"]; !ok || v == nil {
		return fmt.Errorf("field toUserId: required")
	}
	type Plain MintNFTWithItemIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MelandServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MelandServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MelandServiceAction, v)
	}
	*j = MelandServiceAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["skillList"]; !ok || v == nil {
		return fmt.Errorf("field skillList: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatus_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandFightStatus_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandFightStatus_1, v)
	}
	*j = LandFightStatus_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Skill) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["skillId"]; !ok || v == nil {
		return fmt.Errorf("field skillId: required")
	}
	type Plain Skill
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Skill(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandStatus_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandStatus_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandStatus_1, v)
	}
	*j = LandStatus_1(v)
	return nil
}

type Int321 int

type Int322 int

type LandAttributionUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// landId = 地格坐标R*10000 + 地格坐标C
	LandId Int32 `json:"landId"`

	// 地格新的归属状态
	// unoccupied || occupied || ticket || vip
	LandStatus LandStatus `json:"landStatus"`

	// 归属用户id
	UserId string `json:"userId"`
}

type LandFightStatus string

const LandFightStatusAttacked LandFightStatus = "attacked"
const LandFightStatusNormal LandFightStatus = "normal"

type LandFightStatusUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// 状态 attacked || normal
	FightStatus LandFightStatus_1 `json:"fightStatus"`

	// landId = 地格坐标R*10000 + 地格坐标C
	LandId Int32 `json:"landId"`

	// 进攻地块的用户id
	UserId string `json:"userId"`
}

type LandFightStatus_1 string

const LandFightStatus_1_Attacked LandFightStatus_1 = "attacked"
const LandFightStatus_1_Normal LandFightStatus_1 = "normal"

type LandStatus string

const LandStatusNill LandStatus = "nill"
const LandStatusOccupied LandStatus = "occupied"
const LandStatusTicket LandStatus = "ticket"
const LandStatusUnoccupied LandStatus = "unoccupied"
const LandStatusVip LandStatus = "vip"

type LandStatus_1 string

const LandStatus_1_Nill LandStatus_1 = "nill"
const LandStatus_1_Occupied LandStatus_1 = "occupied"
const LandStatus_1_Ticket LandStatus_1 = "ticket"
const LandStatus_1_Unoccupied LandStatus_1 = "unoccupied"
const LandStatus_1_Vip LandStatus_1 = "vip"

// 攻占地格 请求地格中产生效果的skill
type LandUsingSkillInput struct {
	// 消息版本号
	Etag Int322 `json:"etag"`

	// 地格ID
	TileId Int322 `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

// 攻占地格 请求地格skill返回
type LandUsingSkillOutput struct {
	// 消息版本号
	Etag Int322 `json:"etag"`

	// Skill List
	SkillList []Skill `json:"skillList"`

	// 地格ID
	TileId Int322 `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

type MelandServiceAction string

const MelandServiceActionCanBuildNFT MelandServiceAction = "CanBuildNFT"
const MelandServiceActionGetInitLandAttributions MelandServiceAction = "GetInitLandAttributions"
const MelandServiceActionGetUserNFTs MelandServiceAction = "GetUserNFTs"

type MintNFTWithItemIdInput struct {
	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId"`

	// MintCount corresponds to the JSON schema field "mintCount".
	MintCount Int321 `json:"mintCount"`

	// ToUserId corresponds to the JSON schema field "toUserId".
	ToUserId string `json:"toUserId"`
}

type MintNFTWithItemIdOutput struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

type MintNFTWithMetadataInput struct {
	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata NFTMetadata_1 `json:"metadata"`

	// MintCount corresponds to the JSON schema field "mintCount".
	MintCount Int321 `json:"mintCount"`

	// ToUserId corresponds to the JSON schema field "toUserId".
	ToUserId string `json:"toUserId"`
}

type MintNFTWithMetadataOutput struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

type MultiLandAttributionUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// OccupiedLandIds corresponds to the JSON schema field "occupiedLandIds".
	OccupiedLandIds []Int32 `json:"occupiedLandIds"`

	// TicketLandIds corresponds to the JSON schema field "ticketLandIds".
	TicketLandIds []Int32 `json:"ticketLandIds"`

	// 归属用户id
	UserId string `json:"userId"`

	// landId = 地格坐标R*10000 + 地格坐标C
	VipLandIds []Int32 `json:"vipLandIds"`
}

type NFT struct {
	// NFT address
	Address string `json:"address"`

	// NFT id
	Id string `json:"id"`

	// 该NFT是否是Meland.ai官方NFT
	IsMelandAI bool `json:"isMelandAI"`

	// NFT metadata info
	// 目前的实现是, 如果是第三方NFT, 则metadata为空,
	// 直接将tokenURL返回给前端解析即可.
	// example:
	// https://nftmetadata-service-release.melandworld.com/placeable/80000031/1
	Metadata NFTMetadata_1 `json:"metadata"`

	// NFT token id
	TokenId string `json:"tokenId"`

	// NFT metadata url
	// https://nftmetadata-service-release.melandworld.com/placeable/80000031/1
	TokenURL string `json:"tokenURL"`
}

// NFTAttribute 为产品定义的每个NFT的属性.
type NFTAttribute struct {
	// DisplayType corresponds to the JSON schema field "display_type".
	DisplayType *string `json:"display_type,omitempty"`

	// TraitType corresponds to the JSON schema field "trait_type".
	TraitType string `json:"trait_type"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value"`
}

type NFTMetadata_1 struct {
	// NFT gif animation url
	AnimationUrl *string `json:"animation_url,omitempty"`

	// NFT的额外属性.
	Attributes []NFTAttribute `json:"attributes"`

	// BackgroundColor corresponds to the JSON schema field "background_color".
	BackgroundColor *string `json:"background_color,omitempty"`

	// NFT description
	Description string `json:"description"`

	// NFT 扩展url
	// 有扩展URL的NFT社区会实现规范用户点击进行跳转。
	ExternalUrl *string `json:"external_url,omitempty"`

	// NFT image data.
	Image *string `json:"image,omitempty"`

	// ImageData corresponds to the JSON schema field "image_data".
	ImageData *string `json:"image_data,omitempty"`

	// ImageUrl corresponds to the JSON schema field "image_url".
	ImageUrl *string `json:"image_url,omitempty"`

	// NFT name
	Name string `json:"name"`

	// Youtube video url
	YoutubeUrl *string `json:"youtube_url,omitempty"`
}

// NFT放置过期时间结构体
type NFTPlaceableTimeout struct {
	// NFT Id
	NftId string `json:"nftId"`

	// 名字（是否唯一）
	TimeoutSec Int321 `json:"timeoutSec"`
}

// 核心技能id
type NFTTraitCoreSkillId interface{}

type NFTTraitPlaceableLands string

const NFTTraitPlaceableLandsOccupied NFTTraitPlaceableLands = "Occupied"
const NFTTraitPlaceableLandsTicket NFTTraitPlaceableLands = "Ticket"
const NFTTraitPlaceableLandsVIP NFTTraitPlaceableLands = "VIP"

type NFTTraitRarity string

const NFTTraitRarityCommon NFTTraitRarity = "common"
const NFTTraitRarityEpic NFTTraitRarity = "epic"
const NFTTraitRarityMythic NFTTraitRarity = "mythic"
const NFTTraitRarityRare NFTTraitRarity = "rare"
const NFTTraitRarityUnique NFTTraitRarity = "unique"

type NFTTraitSkillLevel interface{}

type NFTTraitType string

const NFTTraitTypeMysteryBox NFTTraitType = "MysteryBox"
const NFTTraitTypePlaceable NFTTraitType = "Placeable"
const NFTTraitTypeWearable NFTTraitType = "Wearable"

type NFTTraitTypes string

const NFTTraitTypesCoreSkillId NFTTraitTypes = "CoreSkillId"
const NFTTraitTypesItemId NFTTraitTypes = "ItemId"
const NFTTraitTypesPlaceableLands NFTTraitTypes = "PlaceableLands"
const NFTTraitTypesRarity NFTTraitTypes = "Rarity"
const NFTTraitTypesSeries NFTTraitTypes = "Series"
const NFTTraitTypesSkillLevel NFTTraitTypes = "SkillLevel"
const NFTTraitTypesType NFTTraitTypes = "Type"
const NFTTraitTypesWearingPosition NFTTraitTypes = "WearingPosition"

type NFTTraitWearingPosition interface{}

type PageMeta struct {
	// Count corresponds to the JSON schema field "count".
	Count float64 `json:"count"`
}

type Sex string

const SexFEMALE Sex = "FEMALE"
const SexMALE Sex = "MALE"

type Sex_1 string

const Sex_1_FEMALE Sex_1 = "FEMALE"
const Sex_1_MALE Sex_1 = "MALE"

type Skill struct {
	// skill level
	Level Int322 `json:"level"`

	// skill Id,  only key
	SkillId Int322 `json:"skillId"`
}

type SubscriptionEvent string

const SubscriptionEventAddUserNFT SubscriptionEvent = "AddUserNFT"
const SubscriptionEventDeleteUserNFT SubscriptionEvent = "DeleteUserNFT"
const SubscriptionEventLandAttributionUpdate SubscriptionEvent = "LandAttributionUpdate"
const SubscriptionEventLandFightStatusUpdate SubscriptionEvent = "LandFightStatusUpdate"
const SubscriptionEventMultiLandAttributionUpdate SubscriptionEvent = "MultiLandAttributionUpdate"

type TemporaryToken struct {
	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt string `json:"createdAt"`

	// ExpiredAt corresponds to the JSON schema field "expiredAt".
	ExpiredAt string `json:"expiredAt"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// TemporaryTokenExtraInfo corresponds to the JSON schema field
	// "temporaryTokenExtraInfo".
	TemporaryTokenExtraInfo *TemporaryTokenExtraInfo `json:"temporaryTokenExtraInfo,omitempty"`

	// Token corresponds to the JSON schema field "token".
	Token string `json:"token"`

	// UpdatedAt corresponds to the JSON schema field "updatedAt".
	UpdatedAt string `json:"updatedAt"`

	// UsedAt corresponds to the JSON schema field "usedAt".
	UsedAt *string `json:"usedAt,omitempty"`
}

type TemporaryTokenExtraInfo struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type User struct {
	// Avatar corresponds to the JSON schema field "avatar".
	Avatar string `json:"avatar"`

	// Email corresponds to the JSON schema field "email".
	Email string `json:"email"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Mobile corresponds to the JSON schema field "mobile".
	Mobile string `json:"mobile"`

	// Nickname corresponds to the JSON schema field "nickname".
	Nickname string `json:"nickname"`

	// Realname corresponds to the JSON schema field "realname".
	Realname string `json:"realname"`

	// SchoolId corresponds to the JSON schema field "schoolId".
	SchoolId string `json:"schoolId"`

	// Sex corresponds to the JSON schema field "sex".
	Sex Sex_1 `json:"sex"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username"`

	// Usertype corresponds to the JSON schema field "usertype".
	Usertype UserType `json:"usertype"`
}

type UserGameDataInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type UserGameDataOutput struct {
	// game name
	Name string `json:"name"`

	// 游戏角色ID
	PlayerId string `json:"playerId"`

	// user id
	UserId string `json:"userId"`
}

// 玩家地格信息数据结构
type UserLandInfo struct {
	// 攻占的地格
	OccupiedLands []Int32 `json:"occupiedLands"`

	// 门票地格
	TicketLands []Int32 `json:"ticketLands"`

	// 购买的地格
	VipLands []Int32 `json:"vipLands"`
}

type UserType string

const UserTypeMANAGER UserType = "MANAGER"
const UserTypeSTUDENT UserType = "STUDENT"
const UserTypeTEACHER UserType = "TEACHER"

type UserType_1 string

const UserType_1_MANAGER UserType_1 = "MANAGER"
const UserType_1_STUDENT UserType_1 = "STUDENT"
const UserType_1_TEACHER UserType_1 = "TEACHER"

type Web3ServiceAction string

const Web3ServiceActionMintNFTWithItemId Web3ServiceAction = "MintNFTWithItemId"
const Web3ServiceActionMintNFTWithMetadata Web3ServiceAction = "MintNFTWithMetadata"

var enumValues_AppId = []interface{}{
	"bellplanet-game",
	"meland-service",
	"web3-service",
}
var enumValues_AuthUserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_GameServiceAction = []interface{}{
	"LandUsingSkill",
}
var enumValues_LandFightStatus = []interface{}{
	"attacked",
	"normal",
}
var enumValues_LandFightStatus_1 = []interface{}{
	"attacked",
	"normal",
}
var enumValues_LandStatus = []interface{}{
	"nill",
	"occupied",
	"ticket",
	"unoccupied",
	"vip",
}
var enumValues_LandStatus_1 = []interface{}{
	"nill",
	"occupied",
	"ticket",
	"unoccupied",
	"vip",
}
var enumValues_MelandServiceAction = []interface{}{
	"CanBuildNFT",
	"GetInitLandAttributions",
	"GetUserNFTs",
}
var enumValues_NFTTraitPlaceableLands = []interface{}{
	"Occupied",
	"Ticket",
	"VIP",
}
var enumValues_NFTTraitRarity = []interface{}{
	"common",
	"epic",
	"mythic",
	"rare",
	"unique",
}
var enumValues_NFTTraitType = []interface{}{
	"MysteryBox",
	"Placeable",
	"Wearable",
}
var enumValues_NFTTraitTypes = []interface{}{
	"CoreSkillId",
	"ItemId",
	"PlaceableLands",
	"Rarity",
	"Series",
	"SkillLevel",
	"Type",
	"WearingPosition",
}
var enumValues_Sex = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_Sex_1 = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_SubscriptionEvent = []interface{}{
	"AddUserNFT",
	"DeleteUserNFT",
	"LandAttributionUpdate",
	"LandFightStatusUpdate",
	"MultiLandAttributionUpdate",
}
var enumValues_UserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_UserType_1 = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_Web3ServiceAction = []interface{}{
	"MintNFTWithItemId",
	"MintNFTWithMetadata",
}
