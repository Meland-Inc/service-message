// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "fmt"
import "reflect"
import "encoding/json"

// UnmarshalJSON implements json.Unmarshaler.
func (j *InitLandAttribution) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landInfos"]; !ok || v == nil {
		return fmt.Errorf("field landInfos: required")
	}
	type Plain InitLandAttribution
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = InitLandAttribution(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType_1, v)
	}
	*j = UserType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserPlaceablesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["placeables"]; !ok || v == nil {
		return fmt.Errorf("field placeables: required")
	}
	if v, ok := raw["thirdInfo"]; !ok || v == nil {
		return fmt.Errorf("field thirdInfo: required")
	}
	if v, ok := raw["thirdTimeOut"]; !ok || v == nil {
		return fmt.Errorf("field thirdTimeOut: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	if v, ok := raw["wearables"]; !ok || v == nil {
		return fmt.Errorf("field wearables: required")
	}
	type Plain UserPlaceablesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserPlaceablesOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTRarity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTRarity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTRarity, v)
	}
	*j = NFTRarity(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserPlaceablesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UserPlaceablesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserPlaceablesInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserGameDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UserGameDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserGameDataOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserGameDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UserGameDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserGameDataInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *User) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatar"]; !ok || v == nil {
		return fmt.Errorf("field avatar: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["mobile"]; !ok || v == nil {
		return fmt.Errorf("field mobile: required")
	}
	if v, ok := raw["nickname"]; !ok || v == nil {
		return fmt.Errorf("field nickname: required")
	}
	if v, ok := raw["realname"]; !ok || v == nil {
		return fmt.Errorf("field realname: required")
	}
	if v, ok := raw["schoolId"]; !ok || v == nil {
		return fmt.Errorf("field schoolId: required")
	}
	if v, ok := raw["sex"]; !ok || v == nil {
		return fmt.Errorf("field sex: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username: required")
	}
	if v, ok := raw["usertype"]; !ok || v == nil {
		return fmt.Errorf("field usertype: required")
	}
	type Plain User
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = User(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType, v)
	}
	*j = UserType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex_1, v)
	}
	*j = Sex_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlaceableSkill) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["skillId"]; !ok || v == nil {
		return fmt.Errorf("field skillId: required")
	}
	type Plain PlaceableSkill
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlaceableSkill(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateThirdNftTimeOut) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["timeOutSec"]; !ok || v == nil {
		return fmt.Errorf("field timeOutSec: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UpdateThirdNftTimeOut
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpdateThirdNftTimeOut(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Placeable) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["objectId"]; !ok || v == nil {
		return fmt.Errorf("field objectId: required")
	}
	if v, ok := raw["placeableId"]; !ok || v == nil {
		return fmt.Errorf("field placeableId: required")
	}
	if v, ok := raw["placeableLand"]; !ok || v == nil {
		return fmt.Errorf("field placeableLand: required")
	}
	if v, ok := raw["rarity"]; !ok || v == nil {
		return fmt.Errorf("field rarity: required")
	}
	if v, ok := raw["skillList"]; !ok || v == nil {
		return fmt.Errorf("field skillList: required")
	}
	type Plain Placeable
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Placeable(plain)
	return nil
}

// 添加用户放置类道具
type AddPlaceable struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// 道具信息
	Placeables Placeable `json:"placeables"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AddPlaceable) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["placeables"]; !ok || v == nil {
		return fmt.Errorf("field placeables: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain AddPlaceable
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AddPlaceable(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThirdNftTimeOut) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["timeOutSec"]; !ok || v == nil {
		return fmt.Errorf("field timeOutSec: required")
	}
	type Plain ThirdNftTimeOut
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ThirdNftTimeOut(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThirdNft) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["desc"]; !ok || v == nil {
		return fmt.Errorf("field desc: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["resUrl"]; !ok || v == nil {
		return fmt.Errorf("field resUrl: required")
	}
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId: required")
	}
	if v, ok := raw["tokenUrl"]; !ok || v == nil {
		return fmt.Errorf("field tokenUrl: required")
	}
	type Plain ThirdNft
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ThirdNft(plain)
	return nil
}

// 添加用户第三方NFT道具
type AddThirdNft struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// 道具信息
	ThirdNft ThirdNft `json:"thirdNft"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AddThirdNft) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["thirdNft"]; !ok || v == nil {
		return fmt.Errorf("field thirdNft: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain AddThirdNft
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AddThirdNft(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["createdAt"]; !ok || v == nil {
		return fmt.Errorf("field createdAt: required")
	}
	if v, ok := raw["expiredAt"]; !ok || v == nil {
		return fmt.Errorf("field expiredAt: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["token"]; !ok || v == nil {
		return fmt.Errorf("field token: required")
	}
	if v, ok := raw["updatedAt"]; !ok || v == nil {
		return fmt.Errorf("field updatedAt: required")
	}
	type Plain TemporaryToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryToken(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryTokenExtraInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain TemporaryTokenExtraInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryTokenExtraInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTRarity_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTRarity_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTRarity_1, v)
	}
	*j = NFTRarity_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex, v)
	}
	*j = Sex(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PageMeta) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		return fmt.Errorf("field count: required")
	}
	type Plain PageMeta
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PageMeta(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NftCanBuildOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["canBuild"]; !ok || v == nil {
		return fmt.Errorf("field canBuild: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	type Plain NftCanBuildOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NftCanBuildOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NftCanBuildInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["aliveTimeSec"]; !ok || v == nil {
		return fmt.Errorf("field aliveTimeSec: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain NftCanBuildInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NftCanBuildInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTRarity_2) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTRarity_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTRarity_2, v)
	}
	*j = NFTRarity_2(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiLandAttributionUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["occupiedLandIds"]; !ok || v == nil {
		return fmt.Errorf("field occupiedLandIds: required")
	}
	if v, ok := raw["ticketLandIds"]; !ok || v == nil {
		return fmt.Errorf("field ticketLandIds: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	if v, ok := raw["vipLandIds"]; !ok || v == nil {
		return fmt.Errorf("field vipLandIds: required")
	}
	type Plain MultiLandAttributionUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiLandAttributionUpdate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WearableNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["objectId"]; !ok || v == nil {
		return fmt.Errorf("field objectId: required")
	}
	if v, ok := raw["rarity"]; !ok || v == nil {
		return fmt.Errorf("field rarity: required")
	}
	type Plain WearableNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WearableNFT(plain)
	return nil
}

// 添加用户第三方NFT道具
type AddWearableNFT struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// 归属用户id
	UserId string `json:"userId"`

	// 装备信息
	Wearable WearableNFT `json:"wearable"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AddWearableNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	if v, ok := raw["wearable"]; !ok || v == nil {
		return fmt.Errorf("field wearable: required")
	}
	type Plain AddWearableNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AddWearableNFT(plain)
	return nil
}

type AuthUserType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["skillList"]; !ok || v == nil {
		return fmt.Errorf("field skillList: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthUserType, v)
	}
	*j = AuthUserType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandStatus_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandStatus_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandStatus_1, v)
	}
	*j = LandStatus_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatusUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["fightStatus"]; !ok || v == nil {
		return fmt.Errorf("field fightStatus: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandFightStatusUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandFightStatusUpdate(plain)
	return nil
}

type Auth struct {
	// AccessToken corresponds to the JSON schema field "accessToken".
	AccessToken string `json:"accessToken"`

	// UserType corresponds to the JSON schema field "userType".
	UserType *AuthUserType `json:"userType,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Auth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["accessToken"]; !ok || v == nil {
		return fmt.Errorf("field accessToken: required")
	}
	type Plain Auth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Auth(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatus_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandFightStatus_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandFightStatus_1, v)
	}
	*j = LandFightStatus_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeleteNft) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain DeleteNft
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DeleteNft(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandFightStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandFightStatus, v)
	}
	*j = LandFightStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandAttributionUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["landStatus"]; !ok || v == nil {
		return fmt.Errorf("field landStatus: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandAttributionUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandAttributionUpdate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserLandInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["occupiedLands"]; !ok || v == nil {
		return fmt.Errorf("field occupiedLands: required")
	}
	if v, ok := raw["ticketLands"]; !ok || v == nil {
		return fmt.Errorf("field ticketLands: required")
	}
	if v, ok := raw["vipLands"]; !ok || v == nil {
		return fmt.Errorf("field vipLands: required")
	}
	type Plain UserLandInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserLandInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandStatus, v)
	}
	*j = LandStatus(v)
	return nil
}

const AuthUserTypeMANAGER AuthUserType = "MANAGER"
const AuthUserTypeSTUDENT AuthUserType = "STUDENT"
const AuthUserTypeTEACHER AuthUserType = "TEACHER"

// 删除用户NFT道具
type DeleteNft struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// Nft Id
	NftId string `json:"nftId"`

	// 归属用户id
	UserId string `json:"userId"`
}

type InitLandAttribution struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// 玩家地格信息 userId = UserLandInfo
	LandInfos InitLandAttributionLandInfos `json:"landInfos"`
}

// 玩家地格信息 userId = UserLandInfo
type InitLandAttributionLandInfos map[string]UserLandInfo

type Int32 int

type Int321 int

type LandAttributionUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// landId = 地格坐标R*10000 + 地格坐标C
	LandId Int32 `json:"landId"`

	// 地格新的归属状态
	// unoccupied || occupied || ticket || vip
	LandStatus LandStatus `json:"landStatus"`

	// 归属用户id
	UserId string `json:"userId"`
}

type LandFightStatus string

const LandFightStatusAttacked LandFightStatus = "attacked"
const LandFightStatusNormal LandFightStatus = "normal"

type LandFightStatusUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// 状态 attacked || normal
	FightStatus LandFightStatus_1 `json:"fightStatus"`

	// landId = 地格坐标R*10000 + 地格坐标C
	LandId Int32 `json:"landId"`

	// 进攻地块的用户id
	UserId string `json:"userId"`
}

type LandFightStatus_1 string

const LandFightStatus_1_Attacked LandFightStatus_1 = "attacked"
const LandFightStatus_1_Normal LandFightStatus_1 = "normal"

type LandStatus string

const LandStatusNill LandStatus = "nill"
const LandStatusOccupied LandStatus = "occupied"
const LandStatusTicket LandStatus = "ticket"
const LandStatusUnoccupied LandStatus = "unoccupied"
const LandStatusVip LandStatus = "vip"

type LandStatus_1 string

const LandStatus_1_Nill LandStatus_1 = "nill"
const LandStatus_1_Occupied LandStatus_1 = "occupied"
const LandStatus_1_Ticket LandStatus_1 = "ticket"
const LandStatus_1_Unoccupied LandStatus_1 = "unoccupied"
const LandStatus_1_Vip LandStatus_1 = "vip"

// 攻占地格 请求地格中产生效果的skill
type LandUsingSkillInput struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// 地格ID
	TileId Int321 `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

// 攻占地格 请求地格skill返回
type LandUsingSkillOutput struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// skill list
	SkillList []PlaceableSkill `json:"skillList"`

	// 地格ID
	TileId Int321 `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

type MultiLandAttributionUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// OccupiedLandIds corresponds to the JSON schema field "occupiedLandIds".
	OccupiedLandIds []Int32 `json:"occupiedLandIds"`

	// TicketLandIds corresponds to the JSON schema field "ticketLandIds".
	TicketLandIds []Int32 `json:"ticketLandIds"`

	// 归属用户id
	UserId string `json:"userId"`

	// landId = 地格坐标R*10000 + 地格坐标C
	VipLandIds []Int32 `json:"vipLandIds"`
}

type NFTRarity string

const NFTRarityCommon NFTRarity = "common"
const NFTRarityEpic NFTRarity = "epic"
const NFTRarityMythic NFTRarity = "mythic"
const NFTRarityRare NFTRarity = "rare"
const NFTRarityUnique NFTRarity = "unique"

type NFTRarity_1 string

const NFTRarity_1_Common NFTRarity_1 = "common"
const NFTRarity_1_Epic NFTRarity_1 = "epic"
const NFTRarity_1_Mythic NFTRarity_1 = "mythic"
const NFTRarity_1_Rare NFTRarity_1 = "rare"
const NFTRarity_1_Unique NFTRarity_1 = "unique"

type NFTRarity_2 string

const NFTRarity_2_Common NFTRarity_2 = "common"
const NFTRarity_2_Epic NFTRarity_2 = "epic"
const NFTRarity_2_Mythic NFTRarity_2 = "mythic"
const NFTRarity_2_Rare NFTRarity_2 = "rare"
const NFTRarity_2_Unique NFTRarity_2 = "unique"

type NftCanBuildInput struct {
	// 实体存活时间，对第三方NFT有效, 单位(秒)
	AliveTimeSec Int321 `json:"aliveTimeSec"`

	// Nft Id
	NftId string `json:"nftId"`

	// 归属用户id
	UserId string `json:"userId"`
}

type NftCanBuildOutput struct {
	// CanBuild corresponds to the JSON schema field "canBuild".
	CanBuild bool `json:"canBuild"`

	// 消息版本号
	Etag Int321 `json:"etag"`

	// Nft Id
	NftId string `json:"nftId"`
}

type PageMeta struct {
	// Count corresponds to the JSON schema field "count".
	Count float64 `json:"count"`
}

// 道具信息数据结构
type Placeable struct {
	// object config Id
	ObjectId Int321 `json:"objectId"`

	// Nft Id
	PlaceableId string `json:"placeableId"`

	// can build land
	PlaceableLand []string `json:"placeableLand"`

	// Placeable Rarity
	Rarity NFTRarity `json:"rarity"`

	// skill list
	SkillList []PlaceableSkill `json:"skillList"`
}

type PlaceableSkill struct {
	// skill level
	Level Int321 `json:"level"`

	// skill Id,  only key
	SkillId Int321 `json:"skillId"`
}

type Sex string

const SexFEMALE Sex = "FEMALE"
const SexMALE Sex = "MALE"

type Sex_1 string

const Sex_1_FEMALE Sex_1 = "FEMALE"
const Sex_1_MALE Sex_1 = "MALE"

type TemporaryToken struct {
	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt string `json:"createdAt"`

	// ExpiredAt corresponds to the JSON schema field "expiredAt".
	ExpiredAt string `json:"expiredAt"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// TemporaryTokenExtraInfo corresponds to the JSON schema field
	// "temporaryTokenExtraInfo".
	TemporaryTokenExtraInfo *TemporaryTokenExtraInfo `json:"temporaryTokenExtraInfo,omitempty"`

	// Token corresponds to the JSON schema field "token".
	Token string `json:"token"`

	// UpdatedAt corresponds to the JSON schema field "updatedAt".
	UpdatedAt string `json:"updatedAt"`

	// UsedAt corresponds to the JSON schema field "usedAt".
	UsedAt *string `json:"usedAt,omitempty"`
}

type TemporaryTokenExtraInfo struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// 第三方NFT信息结构
type ThirdNft struct {
	// 描述信息，
	Desc string `json:"desc"`

	// 名字（是否唯一）
	Name string `json:"name"`

	// Nft Id = address + tokenId
	NftId string `json:"nftId"`

	// 展示图片
	ResUrl string `json:"resUrl"`

	// TokenId corresponds to the JSON schema field "tokenId".
	TokenId string `json:"tokenId"`

	// TokenUrl corresponds to the JSON schema field "tokenUrl".
	TokenUrl string `json:"tokenUrl"`
}

// 第三方NFT过期信息结构
type ThirdNftTimeOut struct {
	// Nft Id
	NftId string `json:"nftId"`

	// 名字（是否唯一）
	TimeOutSec Int321 `json:"timeOutSec"`
}

// 更新 第三方NFT   建造过期时间
type UpdateThirdNftTimeOut struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// Nft Id
	NftId string `json:"nftId"`

	// 过期时间 单位 秒， 清空则给0
	TimeOutSec Int321 `json:"timeOutSec"`

	// 归属用户id
	UserId string `json:"userId"`
}

type User struct {
	// Avatar corresponds to the JSON schema field "avatar".
	Avatar string `json:"avatar"`

	// Email corresponds to the JSON schema field "email".
	Email string `json:"email"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Mobile corresponds to the JSON schema field "mobile".
	Mobile string `json:"mobile"`

	// Nickname corresponds to the JSON schema field "nickname".
	Nickname string `json:"nickname"`

	// Realname corresponds to the JSON schema field "realname".
	Realname string `json:"realname"`

	// SchoolId corresponds to the JSON schema field "schoolId".
	SchoolId string `json:"schoolId"`

	// Sex corresponds to the JSON schema field "sex".
	Sex Sex_1 `json:"sex"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username"`

	// Usertype corresponds to the JSON schema field "usertype".
	Usertype UserType `json:"usertype"`
}

type UserGameDataInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type UserGameDataOutput struct {
	// game name
	Name string `json:"name"`

	// 游戏角色ID
	PlayerId string `json:"playerId"`

	// user id
	UserId string `json:"userId"`
}

// 玩家地格信息数据结构
type UserLandInfo struct {
	// 攻占的地格
	OccupiedLands []Int32 `json:"occupiedLands"`

	// 门票地格
	TicketLands []Int32 `json:"ticketLands"`

	// 购买的地格
	VipLands []Int32 `json:"vipLands"`
}

// 玩家所有的道具信息 请求消息结构
type UserPlaceablesInput struct {
	// 归属用户id
	UserId string `json:"userId"`
}

// 玩家所有的道具信息 返回消息结构
type UserPlaceablesOutput struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// 玩家放置道具信息 Placeable[]
	Placeables []Placeable `json:"placeables"`

	// 第三方NFT LIST
	ThirdInfo []ThirdNft `json:"thirdInfo"`

	// 第三方NFT 放置后的过期时间列表
	ThirdTimeOut []ThirdNftTimeOut `json:"thirdTimeOut"`

	// 归属用户id
	UserId string `json:"userId"`

	// 装备NFT LIST
	Wearables []WearableNFT `json:"wearables"`
}

type UserType string

const UserTypeMANAGER UserType = "MANAGER"
const UserTypeSTUDENT UserType = "STUDENT"
const UserTypeTEACHER UserType = "TEACHER"

type UserType_1 string

const UserType_1_MANAGER UserType_1 = "MANAGER"
const UserType_1_STUDENT UserType_1 = "STUDENT"
const UserType_1_TEACHER UserType_1 = "TEACHER"

// 装备类NFT
type WearableNFT struct {
	// Nft Id
	NftId string `json:"nftId"`

	// object config Id
	ObjectId Int321 `json:"objectId"`

	// Placeable Rarity
	Rarity NFTRarity_1 `json:"rarity"`
}

var enumValues_AuthUserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_LandFightStatus = []interface{}{
	"attacked",
	"normal",
}
var enumValues_LandFightStatus_1 = []interface{}{
	"attacked",
	"normal",
}
var enumValues_LandStatus = []interface{}{
	"nill",
	"occupied",
	"ticket",
	"unoccupied",
	"vip",
}
var enumValues_LandStatus_1 = []interface{}{
	"nill",
	"occupied",
	"ticket",
	"unoccupied",
	"vip",
}
var enumValues_NFTRarity = []interface{}{
	"common",
	"epic",
	"mythic",
	"rare",
	"unique",
}
var enumValues_NFTRarity_1 = []interface{}{
	"common",
	"epic",
	"mythic",
	"rare",
	"unique",
}
var enumValues_NFTRarity_2 = []interface{}{
	"common",
	"epic",
	"mythic",
	"rare",
	"unique",
}
var enumValues_Sex = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_Sex_1 = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_UserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_UserType_1 = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
