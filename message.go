// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "fmt"
import "reflect"
import "encoding/json"

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerUsingNftsByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["UserUsingNfts"]; !ok || v == nil {
		return fmt.Errorf("field UserUsingNfts: required")
	}
	type Plain MultiGetPlayerUsingNftsByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerUsingNftsByUserIdOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Web3ServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Web3ServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Web3ServiceAction, v)
	}
	*j = Web3ServiceAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppId) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppId {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppId, v)
	}
	*j = AppId(v)
	return nil
}

const AppIdBellplanetAccount AppId = "bellplanet-account"
const AppIdBellplanetGame AppId = "bellplanet-game"
const AppIdMelandService AppId = "meland-service"
const AppIdPvpService AppId = "pvp-service"
const AppIdWeb3Service AppId = "web3-service"

type AuthUserType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType_1, v)
	}
	*j = UserType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthUserType, v)
	}
	*j = AuthUserType(v)
	return nil
}

const AuthUserTypeMANAGER AuthUserType = "MANAGER"
const AuthUserTypeSTUDENT AuthUserType = "STUDENT"
const AuthUserTypeTEACHER AuthUserType = "TEACHER"

type Auth struct {
	// AccessToken corresponds to the JSON schema field "accessToken".
	AccessToken string `json:"accessToken"`

	// UserType corresponds to the JSON schema field "userType".
	UserType *AuthUserType `json:"userType,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Auth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["accessToken"]; !ok || v == nil {
		return fmt.Errorf("field accessToken: required")
	}
	type Plain Auth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Auth(plain)
	return nil
}

type BatchMintNFTWithItemIdInputQualitysElem string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserStakeHarvest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["harvestAmountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field harvestAmountOfMELD: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain UserStakeHarvest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserStakeHarvest(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTWithItemIdInputQualitysElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BatchMintNFTWithItemIdInputQualitysElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BatchMintNFTWithItemIdInputQualitysElem, v)
	}
	*j = BatchMintNFTWithItemIdInputQualitysElem(v)
	return nil
}

const BatchMintNFTWithItemIdInputQualitysElemAdvanced BatchMintNFTWithItemIdInputQualitysElem = "Advanced"
const BatchMintNFTWithItemIdInputQualitysElemBasic BatchMintNFTWithItemIdInputQualitysElem = "Basic"
const BatchMintNFTWithItemIdInputQualitysElemEnhanced BatchMintNFTWithItemIdInputQualitysElem = "Enhanced"
const BatchMintNFTWithItemIdInputQualitysElemSuper BatchMintNFTWithItemIdInputQualitysElem = "Super"
const BatchMintNFTWithItemIdInputQualitysElemUltimate BatchMintNFTWithItemIdInputQualitysElem = "Ultimate"

type BatchMintNFTWithItemIdInput struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts"`

	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// 需要mint的所有的itemId
	ItemIds []string `json:"itemIds"`

	// 玩家所在的坐标landId,
	// 当mint场景是捡取掉落物时携带
	LandId int `json:"landId"`

	// 所有的品质
	// index和itemIds一一对应
	QualityVals []string `json:"qualityVals,omitempty"`

	// 所有的品质
	// index和itemIds一一对应
	Qualitys []BatchMintNFTWithItemIdInputQualitysElem `json:"qualitys,omitempty"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTWithItemIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amounts"]; !ok || v == nil {
		return fmt.Errorf("field amounts: required")
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemIds"]; !ok || v == nil {
		return fmt.Errorf("field itemIds: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain BatchMintNFTWithItemIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchMintNFTWithItemIdInput(plain)
	return nil
}

type BatchMintNFTWithItemIdOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTWithItemIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain BatchMintNFTWithItemIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchMintNFTWithItemIdOutput(plain)
	return nil
}

type DitaminBurnSource string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserStakeExpire) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field amountOfMELD: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["stakeLevel"]; !ok || v == nil {
		return fmt.Errorf("field stakeLevel: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain UserStakeExpire
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserStakeExpire(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminBurnSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminBurnSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminBurnSource, v)
	}
	*j = DitaminBurnSource(v)
	return nil
}

const DitaminBurnSourceBuild3DrNFT DitaminBurnSource = "build3drNFT"
const DitaminBurnSourceBuildNFT DitaminBurnSource = "buildNFT"
const DitaminBurnSourceBuyEnergy DitaminBurnSource = "buyEnergy"
const DitaminBurnSourceCraft DitaminBurnSource = "craft"
const DitaminBurnSourceExchange DitaminBurnSource = "exchange"

type BurnDitaminInput struct {
	// 需要燃烧的ditamin数量
	Amount string `json:"amount"`

	// 燃烧的原因
	Source DitaminBurnSource `json:"source"`

	// 燃烧的hash id
	// 用来防止重复燃烧, 每次燃烧调用方需要生成一个txHash.
	// 如果txHash重复, 则不会重复燃烧
	TxHash string `json:"txHash"`

	// 需要燃烧的用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnDitaminInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source: required")
	}
	if v, ok := raw["txHash"]; !ok || v == nil {
		return fmt.Errorf("field txHash: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain BurnDitaminInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnDitaminInput(plain)
	return nil
}

type BurnDitaminOutput struct {
	// 是否燃烧成功
	BurnSuccess bool `json:"burnSuccess"`

	// 如果燃烧失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnDitaminOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["burnSuccess"]; !ok || v == nil {
		return fmt.Errorf("field burnSuccess: required")
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	type Plain BurnDitaminOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnDitaminOutput(plain)
	return nil
}

type BurnNFTInput struct {
	// 丢弃的数量
	Amount int `json:"amount"`

	// 丢弃的NFTId
	NftId string `json:"nftId"`

	// 用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnNFTInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain BurnNFTInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnNFTInput(plain)
	return nil
}

type BurnNFTOutput struct {
	// 是否丢弃成功
	Success bool `json:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnNFTOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain BurnNFTOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnNFTOutput(plain)
	return nil
}

type CanBuildNFTInput struct {
	// 实体存活时间，对第三方NFT有效, 单位(秒)
	AliveTimeSec int `json:"aliveTimeSec"`

	// NFT Id
	NftId string `json:"nftId"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["aliveTimeSec"]; !ok || v == nil {
		return fmt.Errorf("field aliveTimeSec: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain CanBuildNFTInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTInput(plain)
	return nil
}

type CanBuildNFTOutput struct {
	// CanBuild corresponds to the JSON schema field "canBuild".
	CanBuild bool `json:"canBuild"`

	// NFT id
	NftId string `json:"nftId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["canBuild"]; !ok || v == nil {
		return fmt.Errorf("field canBuild: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	type Plain CanBuildNFTOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTOutput(plain)
	return nil
}

type CheckQuestionAnswerInput struct {
	// AnswerJSON corresponds to the JSON schema field "answerJSON".
	AnswerJSON string `json:"answerJSON"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckQuestionAnswerInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["answerJSON"]; !ok || v == nil {
		return fmt.Errorf("field answerJSON: required")
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId: required")
	}
	type Plain CheckQuestionAnswerInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckQuestionAnswerInput(plain)
	return nil
}

type CheckQuestionAnswerOutput struct {
	// IsCorrect corresponds to the JSON schema field "isCorrect".
	IsCorrect bool `json:"isCorrect"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckQuestionAnswerOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["isCorrect"]; !ok || v == nil {
		return fmt.Errorf("field isCorrect: required")
	}
	type Plain CheckQuestionAnswerOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckQuestionAnswerOutput(plain)
	return nil
}

type CreatePVPRoomInput map[string]interface{}

type CreatePVPRoomOutput struct {
	// RoomId corresponds to the JSON schema field "roomId".
	RoomId string `json:"roomId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CreatePVPRoomOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["roomId"]; !ok || v == nil {
		return fmt.Errorf("field roomId: required")
	}
	type Plain CreatePVPRoomOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CreatePVPRoomOutput(plain)
	return nil
}

type DitaminBurnSource_2 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserStakeClaim) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field amountOfMELD: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["stakeLevel"]; !ok || v == nil {
		return fmt.Errorf("field stakeLevel: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain UserStakeClaim
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserStakeClaim(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminBurnSource_2) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminBurnSource_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminBurnSource_2, v)
	}
	*j = DitaminBurnSource_2(v)
	return nil
}

const DitaminBurnSource_2_Build3DrNFT DitaminBurnSource_2 = "build3drNFT"
const DitaminBurnSource_2_BuildNFT DitaminBurnSource_2 = "buildNFT"
const DitaminBurnSource_2_BuyEnergy DitaminBurnSource_2 = "buyEnergy"
const DitaminBurnSource_2_Craft DitaminBurnSource_2 = "craft"
const DitaminBurnSource_2_Exchange DitaminBurnSource_2 = "exchange"

type DitaminBurn struct {
	// ditamin数量
	DitaminAmount string `json:"ditaminAmount"`

	// 消息版本号
	Etag int `json:"etag"`

	// 生产源
	Source DitaminBurnSource_2 `json:"source"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminBurn) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ditaminAmount"]; !ok || v == nil {
		return fmt.Errorf("field ditaminAmount: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain DitaminBurn
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DitaminBurn(plain)
	return nil
}

type DitaminBurnSource_1 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserStakeAdd) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field amountOfMELD: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["stakeLevel"]; !ok || v == nil {
		return fmt.Errorf("field stakeLevel: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain UserStakeAdd
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserStakeAdd(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminBurnSource_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminBurnSource_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminBurnSource_1, v)
	}
	*j = DitaminBurnSource_1(v)
	return nil
}

const DitaminBurnSource_1_Build3DrNFT DitaminBurnSource_1 = "build3drNFT"
const DitaminBurnSource_1_BuildNFT DitaminBurnSource_1 = "buildNFT"
const DitaminBurnSource_1_BuyEnergy DitaminBurnSource_1 = "buyEnergy"
const DitaminBurnSource_1_Craft DitaminBurnSource_1 = "craft"
const DitaminBurnSource_1_Exchange DitaminBurnSource_1 = "exchange"

type AppId string

// UnmarshalJSON implements json.Unmarshaler.
func (j *User) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatar"]; !ok || v == nil {
		return fmt.Errorf("field avatar: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["mobile"]; !ok || v == nil {
		return fmt.Errorf("field mobile: required")
	}
	if v, ok := raw["nickname"]; !ok || v == nil {
		return fmt.Errorf("field nickname: required")
	}
	if v, ok := raw["realname"]; !ok || v == nil {
		return fmt.Errorf("field realname: required")
	}
	if v, ok := raw["schoolId"]; !ok || v == nil {
		return fmt.Errorf("field schoolId: required")
	}
	if v, ok := raw["sex"]; !ok || v == nil {
		return fmt.Errorf("field sex: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username: required")
	}
	if v, ok := raw["usertype"]; !ok || v == nil {
		return fmt.Errorf("field usertype: required")
	}
	type Plain User
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = User(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminProduceSource_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminProduceSource_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminProduceSource_1, v)
	}
	*j = DitaminProduceSource_1(v)
	return nil
}

const DitaminProduceSource_1_AttackFinlish DitaminProduceSource_1 = "attackFinlish"
const DitaminProduceSource_1_Deposit DitaminProduceSource_1 = "deposit"
const DitaminProduceSource_1_Harvest DitaminProduceSource_1 = "harvest"

type DitaminProduce struct {
	// ditamin数量
	DitaminAmount string `json:"ditaminAmount"`

	// 消息版本号
	Etag int `json:"etag"`

	// 生产源
	Source DitaminProduceSource_1 `json:"source"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminProduce) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ditaminAmount"]; !ok || v == nil {
		return fmt.Errorf("field ditaminAmount: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain DitaminProduce
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DitaminProduce(plain)
	return nil
}

type DitaminProduceSource string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType, v)
	}
	*j = UserType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminProduceSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminProduceSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminProduceSource, v)
	}
	*j = DitaminProduceSource(v)
	return nil
}

const DitaminProduceSourceAttackFinlish DitaminProduceSource = "attackFinlish"
const DitaminProduceSourceDeposit DitaminProduceSource = "deposit"
const DitaminProduceSourceHarvest DitaminProduceSource = "harvest"

type FinishQuestion struct {
	// DiffcultyChange corresponds to the JSON schema field "diffcultyChange".
	DiffcultyChange float64 `json:"diffcultyChange"`

	// 消息版本号
	Etag int `json:"etag"`

	// Level corresponds to the JSON schema field "level".
	Level string `json:"level"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId"`

	// Result corresponds to the JSON schema field "result".
	Result string `json:"result"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FinishQuestion) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["diffcultyChange"]; !ok || v == nil {
		return fmt.Errorf("field diffcultyChange: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId: required")
	}
	if v, ok := raw["result"]; !ok || v == nil {
		return fmt.Errorf("field result: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain FinishQuestion
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FinishQuestion(plain)
	return nil
}

type GameAccountServiceAction string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex_1, v)
	}
	*j = Sex_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GameAccountServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GameAccountServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GameAccountServiceAction, v)
	}
	*j = GameAccountServiceAction(v)
	return nil
}

const GameAccountServiceActionGetPlayerInfoByUserId GameAccountServiceAction = "GetPlayerInfoByUserId"
const GameAccountServiceActionGetPlayerItemSockets GameAccountServiceAction = "GetPlayerItemSockets"
const GameAccountServiceActionGetPlayerUsingNftsByUserId GameAccountServiceAction = "GetPlayerUsingNftsByUserId"
const GameAccountServiceActionMultiGetPlayerInfoByUserId GameAccountServiceAction = "MultiGetPlayerInfoByUserId"
const GameAccountServiceActionMultiGetPlayerUsingNftsByUserId GameAccountServiceAction = "MultiGetPlayerUsingNftsByUserId"
const GameAccountServiceActionUpgradePlayerItemSockets GameAccountServiceAction = "UpgradePlayerItemSockets"

type GameServiceAction string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseEquipment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatarPos"]; !ok || v == nil {
		return fmt.Errorf("field avatarPos: required")
	}
	if v, ok := raw["cid"]; !ok || v == nil {
		return fmt.Errorf("field cid: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UseEquipment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseEquipment(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GameServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GameServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GameServiceAction, v)
	}
	*j = GameServiceAction(v)
	return nil
}

const GameServiceActionLandUsingSkill GameServiceAction = "LandUsingSkill"

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseConsumabled) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["nft"]; !ok || v == nil {
		return fmt.Errorf("field nft: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UseConsumabled
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseConsumabled(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseConsumableOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UseConsumableOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseConsumableOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPUserType, v)
	}
	*j = PVPUserType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseConsumableInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UseConsumableInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseConsumableInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpgradePlayerItemSocketsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UpgradePlayerItemSocketsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpgradePlayerItemSocketsOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpgradePlayerItemSocketsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["itemSockets"]; !ok || v == nil {
		return fmt.Errorf("field itemSockets: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UpgradePlayerItemSocketsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpgradePlayerItemSocketsInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPPlayer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain PVPPlayer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPPlayer(plain)
	return nil
}

type GetCurrentPkSessionIdInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetCurrentPkSessionIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	type Plain GetCurrentPkSessionIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetCurrentPkSessionIdInput(plain)
	return nil
}

type GetCurrentPkSessionIdOutput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetCurrentPkSessionIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	type Plain GetCurrentPkSessionIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetCurrentPkSessionIdOutput(plain)
	return nil
}

type GetInitLandAttributionsInput map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateUserNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["fromLandId"]; !ok || v == nil {
		return fmt.Errorf("field fromLandId: required")
	}
	if v, ok := raw["nft"]; !ok || v == nil {
		return fmt.Errorf("field nft: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UpdateUserNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpdateUserNFT(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserLandInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["occupiedLands"]; !ok || v == nil {
		return fmt.Errorf("field occupiedLands: required")
	}
	if v, ok := raw["ticketLands"]; !ok || v == nil {
		return fmt.Errorf("field ticketLands: required")
	}
	if v, ok := raw["vipLands"]; !ok || v == nil {
		return fmt.Errorf("field vipLands: required")
	}
	type Plain UserLandInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserLandInfo(plain)
	return nil
}

// 玩家地格信息 userId = UserLandInfo
type GetInitLandAttributionsOutputLandInfos map[string]UserLandInfo

type GetInitLandAttributionsOutput struct {
	// 消息版本号
	Etag int `json:"etag"`

	// 玩家地格信息 userId = UserLandInfo
	LandInfos GetInitLandAttributionsOutputLandInfos `json:"landInfos"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetInitLandAttributionsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landInfos"]; !ok || v == nil {
		return fmt.Errorf("field landInfos: required")
	}
	type Plain GetInitLandAttributionsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetInitLandAttributionsOutput(plain)
	return nil
}

type GetPlayerInfoByUserIdInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerInfoByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetPlayerInfoByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerInfoByUserIdInput(plain)
	return nil
}

type GetPlayerInfoByUserIdOutput struct {
	// Feature corresponds to the JSON schema field "feature".
	Feature string `json:"feature"`

	// Icon corresponds to the JSON schema field "icon".
	Icon string `json:"icon"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`

	// PlayerName corresponds to the JSON schema field "playerName".
	PlayerName string `json:"playerName"`

	// 角色cid (男性 1001 / 女性 1002)
	RoleCId int `json:"roleCId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerInfoByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["feature"]; !ok || v == nil {
		return fmt.Errorf("field feature: required")
	}
	if v, ok := raw["icon"]; !ok || v == nil {
		return fmt.Errorf("field icon: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["playerName"]; !ok || v == nil {
		return fmt.Errorf("field playerName: required")
	}
	if v, ok := raw["roleCId"]; !ok || v == nil {
		return fmt.Errorf("field roleCId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetPlayerInfoByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerInfoByUserIdOutput(plain)
	return nil
}

type GetPlayerItemSocketsInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerItemSocketsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetPlayerItemSocketsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerItemSocketsInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnloadEquipment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UnloadEquipment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UnloadEquipment(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerItemSocket) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position: required")
	}
	type Plain PlayerItemSocket
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerItemSocket(plain)
	return nil
}

type GetPlayerItemSocketsOutput struct {
	// ItemSockets corresponds to the JSON schema field "itemSockets".
	ItemSockets []PlayerItemSocket `json:"itemSockets"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerItemSocketsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["itemSockets"]; !ok || v == nil {
		return fmt.Errorf("field itemSockets: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetPlayerItemSocketsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerItemSocketsOutput(plain)
	return nil
}

type GetPlayerPvpProfileInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpProfileInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	type Plain GetPlayerPvpProfileInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpProfileInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["createdAt"]; !ok || v == nil {
		return fmt.Errorf("field createdAt: required")
	}
	if v, ok := raw["expiredAt"]; !ok || v == nil {
		return fmt.Errorf("field expiredAt: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["token"]; !ok || v == nil {
		return fmt.Errorf("field token: required")
	}
	if v, ok := raw["updatedAt"]; !ok || v == nil {
		return fmt.Errorf("field updatedAt: required")
	}
	type Plain TemporaryToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryToken(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerAvatar) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["cid"]; !ok || v == nil {
		return fmt.Errorf("field cid: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["nftJson"]; !ok || v == nil {
		return fmt.Errorf("field nftJson: required")
	}
	if v, ok := raw["pos"]; !ok || v == nil {
		return fmt.Errorf("field pos: required")
	}
	type Plain PlayerAvatar
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerAvatar(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryTokenExtraInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain TemporaryTokenExtraInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryTokenExtraInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["feature"]; !ok || v == nil {
		return fmt.Errorf("field feature: required")
	}
	if v, ok := raw["icon"]; !ok || v == nil {
		return fmt.Errorf("field icon: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["playerName"]; !ok || v == nil {
		return fmt.Errorf("field playerName: required")
	}
	if v, ok := raw["roleCId"]; !ok || v == nil {
		return fmt.Errorf("field roleCId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain PlayerInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerInfo(plain)
	return nil
}

type Integer float64

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpPlayerProfile) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatars"]; !ok || v == nil {
		return fmt.Errorf("field avatars: required")
	}
	if v, ok := raw["baseInfo"]; !ok || v == nil {
		return fmt.Errorf("field baseInfo: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["score"]; !ok || v == nil {
		return fmt.Errorf("field score: required")
	}
	type Plain PvpPlayerProfile
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpPlayerProfile(plain)
	return nil
}

type GetPlayerPvpProfileOutput struct {
	// Profile corresponds to the JSON schema field "profile".
	Profile PvpPlayerProfile `json:"profile"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpProfileOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["profile"]; !ok || v == nil {
		return fmt.Errorf("field profile: required")
	}
	type Plain GetPlayerPvpProfileOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpProfileOutput(plain)
	return nil
}

type GetPlayerPvpRankInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpRankInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	type Plain GetPlayerPvpRankInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpRankInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionEvent) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubscriptionEvent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubscriptionEvent, v)
	}
	*j = SubscriptionEvent(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpPlayerRank) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatars"]; !ok || v == nil {
		return fmt.Errorf("field avatars: required")
	}
	if v, ok := raw["baseInfo"]; !ok || v == nil {
		return fmt.Errorf("field baseInfo: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["rank"]; !ok || v == nil {
		return fmt.Errorf("field rank: required")
	}
	if v, ok := raw["score"]; !ok || v == nil {
		return fmt.Errorf("field score: required")
	}
	type Plain PvpPlayerRank
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpPlayerRank(plain)
	return nil
}

type GetPlayerPvpRankOutput struct {
	// RankList corresponds to the JSON schema field "rankList".
	RankList []PvpPlayerRank `json:"rankList"`

	// SelfRank corresponds to the JSON schema field "selfRank".
	SelfRank PvpPlayerRank `json:"selfRank"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpRankOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["rankList"]; !ok || v == nil {
		return fmt.Errorf("field rankList: required")
	}
	if v, ok := raw["selfRank"]; !ok || v == nil {
		return fmt.Errorf("field selfRank: required")
	}
	type Plain GetPlayerPvpRankOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpRankOutput(plain)
	return nil
}

type GetPlayerUsingNftsByUserIdInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerUsingNftsByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetPlayerUsingNftsByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerUsingNftsByUserIdInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex, v)
	}
	*j = Sex(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UsingNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatarPos"]; !ok || v == nil {
		return fmt.Errorf("field avatarPos: required")
	}
	if v, ok := raw["cid"]; !ok || v == nil {
		return fmt.Errorf("field cid: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UsingNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UsingNFT(plain)
	return nil
}

type GetPlayerUsingNftsByUserIdOutput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`

	// UsingNfts corresponds to the JSON schema field "usingNfts".
	UsingNfts []UsingNFT `json:"usingNfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerUsingNftsByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	if v, ok := raw["usingNfts"]; !ok || v == nil {
		return fmt.Errorf("field usingNfts: required")
	}
	type Plain GetPlayerUsingNftsByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerUsingNftsByUserIdOutput(plain)
	return nil
}

type GetPvpHistoryInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPvpHistoryInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	type Plain GetPvpHistoryInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPvpHistoryInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuestionType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuestionType_1, v)
	}
	*j = QuestionType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpHistory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["endType"]; !ok || v == nil {
		return fmt.Errorf("field endType: required")
	}
	if v, ok := raw["loser"]; !ok || v == nil {
		return fmt.Errorf("field loser: required")
	}
	if v, ok := raw["loserName"]; !ok || v == nil {
		return fmt.Errorf("field loserName: required")
	}
	if v, ok := raw["loserScore"]; !ok || v == nil {
		return fmt.Errorf("field loserScore: required")
	}
	if v, ok := raw["pvpType"]; !ok || v == nil {
		return fmt.Errorf("field pvpType: required")
	}
	if v, ok := raw["scoreOffset"]; !ok || v == nil {
		return fmt.Errorf("field scoreOffset: required")
	}
	if v, ok := raw["timeSec"]; !ok || v == nil {
		return fmt.Errorf("field timeSec: required")
	}
	if v, ok := raw["winner"]; !ok || v == nil {
		return fmt.Errorf("field winner: required")
	}
	if v, ok := raw["winnerName"]; !ok || v == nil {
		return fmt.Errorf("field winnerName: required")
	}
	if v, ok := raw["winnerScore"]; !ok || v == nil {
		return fmt.Errorf("field winnerScore: required")
	}
	type Plain PvpHistory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpHistory(plain)
	return nil
}

type GetPvpHistoryOutput struct {
	// HistoryList corresponds to the JSON schema field "historyList".
	HistoryList []PvpHistory `json:"historyList"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPvpHistoryOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["historyList"]; !ok || v == nil {
		return fmt.Errorf("field historyList: required")
	}
	type Plain GetPvpHistoryOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPvpHistoryOutput(plain)
	return nil
}

type GetQuestionResourcesByTypesInput struct {
	// Types corresponds to the JSON schema field "types".
	Types []string `json:"types"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionResourcesByTypesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["types"]; !ok || v == nil {
		return fmt.Errorf("field types: required")
	}
	type Plain GetQuestionResourcesByTypesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionResourcesByTypesInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpSurrenderOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success: required")
	}
	type Plain PvpSurrenderOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpSurrenderOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpSurrenderInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	type Plain PvpSurrenderInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpSurrenderInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuestionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuestionType, v)
	}
	*j = QuestionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerRebornType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PlayerRebornType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PlayerRebornType, v)
	}
	*j = PlayerRebornType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerReborn) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["rebornLandId"]; !ok || v == nil {
		return fmt.Errorf("field rebornLandId: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain PlayerReborn
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerReborn(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerRebornType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PlayerRebornType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PlayerRebornType_1, v)
	}
	*j = PlayerRebornType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerKilled) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["killedLandId"]; !ok || v == nil {
		return fmt.Errorf("field killedLandId: required")
	}
	if v, ok := raw["lastDamage"]; !ok || v == nil {
		return fmt.Errorf("field lastDamage: required")
	}
	if v, ok := raw["targetId"]; !ok || v == nil {
		return fmt.Errorf("field targetId: required")
	}
	if v, ok := raw["targetName"]; !ok || v == nil {
		return fmt.Errorf("field targetName: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain PlayerKilled
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerKilled(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerDeath) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["deathLandId"]; !ok || v == nil {
		return fmt.Errorf("field deathLandId: required")
	}
	if v, ok := raw["killerId"]; !ok || v == nil {
		return fmt.Errorf("field killerId: required")
	}
	if v, ok := raw["killerName"]; !ok || v == nil {
		return fmt.Errorf("field killerName: required")
	}
	if v, ok := raw["lastDamage"]; !ok || v == nil {
		return fmt.Errorf("field lastDamage: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain PlayerDeath
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerDeath(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionUITickInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data: required")
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	type Plain PkSessionUITickInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionUITickInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionLoadSuccessInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	type Plain PkSessionLoadSuccessInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionLoadSuccessInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionDoQuestionOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["isCorrect"]; !ok || v == nil {
		return fmt.Errorf("field isCorrect: required")
	}
	type Plain PkSessionDoQuestionOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionDoQuestionOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionDoQuestionInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId: required")
	}
	type Plain PkSessionDoQuestionInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionDoQuestionInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionAgainOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkRoomId"]; !ok || v == nil {
		return fmt.Errorf("field pkRoomId: required")
	}
	type Plain PkSessionAgainOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionAgainOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionAgainInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId: required")
	}
	type Plain PkSessionAgainInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionAgainInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PageMeta) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		return fmt.Errorf("field count: required")
	}
	type Plain PageMeta
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PageMeta(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPUserType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPUserType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPUserType_1, v)
	}
	*j = PVPUserType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Prefetch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId: required")
	}
	if v, ok := raw["questionType"]; !ok || v == nil {
		return fmt.Errorf("field questionType: required")
	}
	if v, ok := raw["resources"]; !ok || v == nil {
		return fmt.Errorf("field resources: required")
	}
	type Plain Prefetch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Prefetch(plain)
	return nil
}

type GetQuestionResourcesByTypesOutput struct {
	// Prefetchs corresponds to the JSON schema field "prefetchs".
	Prefetchs []Prefetch `json:"prefetchs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionResourcesByTypesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["prefetchs"]; !ok || v == nil {
		return fmt.Errorf("field prefetchs: required")
	}
	type Plain GetQuestionResourcesByTypesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionResourcesByTypesOutput(plain)
	return nil
}

type GetQuestionsByTypesRandomInput struct {
	// Limit corresponds to the JSON schema field "limit".
	Limit int `json:"limit"`

	// Types corresponds to the JSON schema field "types".
	Types []string `json:"types"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionsByTypesRandomInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		return fmt.Errorf("field limit: required")
	}
	if v, ok := raw["types"]; !ok || v == nil {
		return fmt.Errorf("field types: required")
	}
	type Plain GetQuestionsByTypesRandomInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionsByTypesRandomInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPType, v)
	}
	*j = PVPType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Question) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["structJSON"]; !ok || v == nil {
		return fmt.Errorf("field structJSON: required")
	}
	type Plain Question
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Question(plain)
	return nil
}

type GetQuestionsByTypesRandomOutput struct {
	// Questions corresponds to the JSON schema field "questions".
	Questions []Question `json:"questions"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionsByTypesRandomOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["questions"]; !ok || v == nil {
		return fmt.Errorf("field questions: required")
	}
	type Plain GetQuestionsByTypesRandomOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionsByTypesRandomOutput(plain)
	return nil
}

type GetUserIdByAddressInput struct {
	// BlockchainAddress corresponds to the JSON schema field "blockchainAddress".
	BlockchainAddress string `json:"blockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserIdByAddressInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field blockchainAddress: required")
	}
	type Plain GetUserIdByAddressInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserIdByAddressInput(plain)
	return nil
}

type GetUserIdByAddressOutput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserIdByAddressOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserIdByAddressOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserIdByAddressOutput(plain)
	return nil
}

type GetUserNFTsByUserIdAndAddressInput struct {
	// 用户钱包地址
	BlockchainAddress string `json:"blockchainAddress"`

	// 用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsByUserIdAndAddressInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field blockchainAddress: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserNFTsByUserIdAndAddressInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsByUserIdAndAddressInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPSubscriptionEvent) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPSubscriptionEvent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPSubscriptionEvent, v)
	}
	*j = PVPSubscriptionEvent(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTAttribute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trait_type"]; !ok || v == nil {
		return fmt.Errorf("field trait_type: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain NFTAttribute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTAttribute(plain)
	return nil
}

// 有一些配置表格的数据不希望显示在opensea中,
// 但是为了方便统一解析。
// 生成到这个表格中.
type MelandAttribute struct {
	// TraitType corresponds to the JSON schema field "trait_type".
	TraitType string `json:"trait_type"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MelandAttribute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trait_type"]; !ok || v == nil {
		return fmt.Errorf("field trait_type: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain MelandAttribute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MelandAttribute(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPServiceAction, v)
	}
	*j = PVPServiceAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTMetadata_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["attributes"]; !ok || v == nil {
		return fmt.Errorf("field attributes: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain NFTMetadata_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTMetadata_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomReadyInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	if v, ok := raw["pvpRoomId"]; !ok || v == nil {
		return fmt.Errorf("field pvpRoomId: required")
	}
	type Plain PVPRoomReadyInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomReadyInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["amountOfChange"]; !ok || v == nil {
		return fmt.Errorf("field amountOfChange: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["isMelandAI"]; !ok || v == nil {
		return fmt.Errorf("field isMelandAI: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["network"]; !ok || v == nil {
		return fmt.Errorf("field network: required")
	}
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId: required")
	}
	if v, ok := raw["tokenURL"]; !ok || v == nil {
		return fmt.Errorf("field tokenURL: required")
	}
	type Plain NFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFT(plain)
	return nil
}

type GetUserNFTsByUserIdAndAddressOutput struct {
	// Nfts corresponds to the JSON schema field "nfts".
	Nfts []NFT `json:"nfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsByUserIdAndAddressOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts: required")
	}
	type Plain GetUserNFTsByUserIdAndAddressOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsByUserIdAndAddressOutput(plain)
	return nil
}

type GetUserNFTsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserNFTsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomPreLeaveOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["canLeave"]; !ok || v == nil {
		return fmt.Errorf("field canLeave: required")
	}
	type Plain PVPRoomPreLeaveOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomPreLeaveOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTPlaceableTimeout) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["timeoutSec"]; !ok || v == nil {
		return fmt.Errorf("field timeoutSec: required")
	}
	type Plain NFTPlaceableTimeout
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTPlaceableTimeout(plain)
	return nil
}

type GetUserNFTsOutput struct {
	// 消息版本号
	Etag int `json:"etag"`

	// user all nfts
	Nfts []NFT `json:"nfts"`

	// NFT放置过期时间表
	PlaceableTimeouts []NFTPlaceableTimeout `json:"placeableTimeouts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts: required")
	}
	if v, ok := raw["placeableTimeouts"]; !ok || v == nil {
		return fmt.Errorf("field placeableTimeouts: required")
	}
	type Plain GetUserNFTsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsOutput(plain)
	return nil
}

type GetUserRecipesInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRecipesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserRecipesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRecipesInput(plain)
	return nil
}

type GetUserRecipesOutput struct {
	// RecipeIds corresponds to the JSON schema field "recipeIds".
	RecipeIds []string `json:"recipeIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRecipesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["recipeIds"]; !ok || v == nil {
		return fmt.Errorf("field recipeIds: required")
	}
	type Plain GetUserRecipesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRecipesOutput(plain)
	return nil
}

type GetUserWeb3ProfileInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserWeb3ProfileInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserWeb3ProfileInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserWeb3ProfileInput(plain)
	return nil
}

type GetUserWeb3ProfileOutput struct {
	// BlockchainAddress corresponds to the JSON schema field "blockchainAddress".
	BlockchainAddress string `json:"blockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserWeb3ProfileOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field blockchainAddress: required")
	}
	type Plain GetUserWeb3ProfileOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserWeb3ProfileOutput(plain)
	return nil
}

type Int32 int

type LandStatus string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomPreLeaveInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	if v, ok := raw["roomId"]; !ok || v == nil {
		return fmt.Errorf("field roomId: required")
	}
	type Plain PVPRoomPreLeaveInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomPreLeaveInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandStatus, v)
	}
	*j = LandStatus(v)
	return nil
}

const LandStatusNill LandStatus = "Nill"
const LandStatusOccupied LandStatus = "Occupied"
const LandStatusTicket LandStatus = "Ticket"
const LandStatusUnoccupied LandStatus = "Unoccupied"
const LandStatusVIP LandStatus = "VIP"

type LandAttributionUpdate struct {
	// 消息版本号
	Etag int `json:"etag"`

	// landId = 地格坐标R*10000 + 地格坐标C
	LandId int `json:"landId"`

	// 上一个用户归属id
	LandOwnerId string `json:"landOwnerId"`

	// 地格新的归属状态
	// unoccupied || occupied || ticket || vip
	LandStatus LandStatus `json:"landStatus"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandAttributionUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["landOwnerId"]; !ok || v == nil {
		return fmt.Errorf("field landOwnerId: required")
	}
	if v, ok := raw["landStatus"]; !ok || v == nil {
		return fmt.Errorf("field landStatus: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandAttributionUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandAttributionUpdate(plain)
	return nil
}

type LandFightStatus string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPPKSessionStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPPKSessionStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPPKSessionStatus, v)
	}
	*j = PVPPKSessionStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandFightStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandFightStatus, v)
	}
	*j = LandFightStatus(v)
	return nil
}

const LandFightStatusAttacked LandFightStatus = "attacked"
const LandFightStatusNormal LandFightStatus = "normal"

type LandFightStatus_1 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchLeaveOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["succese"]; !ok || v == nil {
		return fmt.Errorf("field succese: required")
	}
	type Plain PVPMatchLeaveOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchLeaveOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatus_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandFightStatus_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandFightStatus_1, v)
	}
	*j = LandFightStatus_1(v)
	return nil
}

const LandFightStatus_1_Attacked LandFightStatus_1 = "attacked"
const LandFightStatus_1_Normal LandFightStatus_1 = "normal"

type LandFightStatusUpdate struct {
	// 消息版本号
	Etag int `json:"etag"`

	// 状态 attacked || normal
	FightStatus LandFightStatus_1 `json:"fightStatus"`

	// landId = 地格坐标R*10000 + 地格坐标C
	LandId int `json:"landId"`

	// 进攻地块的用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatusUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["fightStatus"]; !ok || v == nil {
		return fmt.Errorf("field fightStatus: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandFightStatusUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandFightStatusUpdate(plain)
	return nil
}

type LandStatus_1 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchLeaveInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	type Plain PVPMatchLeaveInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchLeaveInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandStatus_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandStatus_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandStatus_1, v)
	}
	*j = LandStatus_1(v)
	return nil
}

const LandStatus_1_Nill LandStatus_1 = "Nill"
const LandStatus_1_Occupied LandStatus_1 = "Occupied"
const LandStatus_1_Ticket LandStatus_1 = "Ticket"
const LandStatus_1_Unoccupied LandStatus_1 = "Unoccupied"
const LandStatus_1_VIP LandStatus_1 = "VIP"

// 攻占地格 请求地格中产生效果的skill
type LandUsingSkillInput struct {
	// 消息版本号
	Etag int `json:"etag"`

	// 地格ID
	TileId int `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchEnterOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["succese"]; !ok || v == nil {
		return fmt.Errorf("field succese: required")
	}
	type Plain PVPMatchEnterOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchEnterOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Skill) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["skillId"]; !ok || v == nil {
		return fmt.Errorf("field skillId: required")
	}
	type Plain Skill
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Skill(plain)
	return nil
}

// 攻占地格 请求地格skill返回
type LandUsingSkillOutput struct {
	// 消息版本号
	Etag int `json:"etag"`

	// Skill List
	SkillList []Skill `json:"skillList"`

	// 地格ID
	TileId int `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["skillList"]; !ok || v == nil {
		return fmt.Errorf("field skillList: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillOutput(plain)
	return nil
}

type MELDExchange2Ditamin struct {
	// AmountOfMELD corresponds to the JSON schema field "amountOfMELD".
	AmountOfMELD string `json:"amountOfMELD"`

	// DepositId corresponds to the JSON schema field "depositId".
	DepositId string `json:"depositId"`

	// DitaminAmount corresponds to the JSON schema field "ditaminAmount".
	DitaminAmount string `json:"ditaminAmount"`

	// 消息版本号
	Etag int `json:"etag"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MELDExchange2Ditamin) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field amountOfMELD: required")
	}
	if v, ok := raw["depositId"]; !ok || v == nil {
		return fmt.Errorf("field depositId: required")
	}
	if v, ok := raw["ditaminAmount"]; !ok || v == nil {
		return fmt.Errorf("field ditaminAmount: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain MELDExchange2Ditamin
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MELDExchange2Ditamin(plain)
	return nil
}

type MELDFutureExchangeRateChange struct {
	// 消息版本号
	Etag int `json:"etag"`

	// ExchangeRate corresponds to the JSON schema field "exchangeRate".
	ExchangeRate string `json:"exchangeRate"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MELDFutureExchangeRateChange) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["exchangeRate"]; !ok || v == nil {
		return fmt.Errorf("field exchangeRate: required")
	}
	type Plain MELDFutureExchangeRateChange
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MELDFutureExchangeRateChange(plain)
	return nil
}

type MELDFutureMint struct {
	// 花费多少ditamin
	DitaminAmount string `json:"ditaminAmount"`

	// 期货价值余额
	FutureAmount string `json:"futureAmount"`

	// MfId corresponds to the JSON schema field "mfId".
	MfId string `json:"mfId"`

	// 获得的用户钱包地址
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MELDFutureMint) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ditaminAmount"]; !ok || v == nil {
		return fmt.Errorf("field ditaminAmount: required")
	}
	if v, ok := raw["futureAmount"]; !ok || v == nil {
		return fmt.Errorf("field futureAmount: required")
	}
	if v, ok := raw["mfId"]; !ok || v == nil {
		return fmt.Errorf("field mfId: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain MELDFutureMint
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MELDFutureMint(plain)
	return nil
}

type MELDFutureRelease struct {
	// AmountOfMELD corresponds to the JSON schema field "amountOfMELD".
	AmountOfMELD string `json:"amountOfMELD"`

	// 消息版本号
	Etag int `json:"etag"`

	// MfId corresponds to the JSON schema field "mfId".
	MfId string `json:"mfId"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MELDFutureRelease) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amountOfMELD"]; !ok || v == nil {
		return fmt.Errorf("field amountOfMELD: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["mfId"]; !ok || v == nil {
		return fmt.Errorf("field mfId: required")
	}
	if v, ok := raw["userBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field userBlockchainAddress: required")
	}
	type Plain MELDFutureRelease
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MELDFutureRelease(plain)
	return nil
}

type MarketplaceTrade struct {
	// BuyerBlockchainAddress corresponds to the JSON schema field
	// "buyerBlockchainAddress".
	BuyerBlockchainAddress string `json:"buyerBlockchainAddress"`

	// ChainName corresponds to the JSON schema field "chainName".
	ChainName string `json:"chainName"`

	// 消息版本号
	Etag int `json:"etag"`

	// Nft corresponds to the JSON schema field "nft".
	Nft NFT `json:"nft"`

	// SellerBlockchainAddress corresponds to the JSON schema field
	// "sellerBlockchainAddress".
	SellerBlockchainAddress string `json:"sellerBlockchainAddress"`

	// TokenAmount corresponds to the JSON schema field "tokenAmount".
	TokenAmount string `json:"tokenAmount"`

	// TokenType corresponds to the JSON schema field "tokenType".
	TokenType string `json:"tokenType"`

	// Txn corresponds to the JSON schema field "txn".
	Txn string `json:"txn"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MarketplaceTrade) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buyerBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field buyerBlockchainAddress: required")
	}
	if v, ok := raw["chainName"]; !ok || v == nil {
		return fmt.Errorf("field chainName: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nft"]; !ok || v == nil {
		return fmt.Errorf("field nft: required")
	}
	if v, ok := raw["sellerBlockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field sellerBlockchainAddress: required")
	}
	if v, ok := raw["tokenAmount"]; !ok || v == nil {
		return fmt.Errorf("field tokenAmount: required")
	}
	if v, ok := raw["tokenType"]; !ok || v == nil {
		return fmt.Errorf("field tokenType: required")
	}
	if v, ok := raw["txn"]; !ok || v == nil {
		return fmt.Errorf("field txn: required")
	}
	type Plain MarketplaceTrade
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MarketplaceTrade(plain)
	return nil
}

type MelandServiceAction string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchEnterInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player: required")
	}
	type Plain PVPMatchEnterInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchEnterInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MelandServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MelandServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MelandServiceAction, v)
	}
	*j = MelandServiceAction(v)
	return nil
}

const MelandServiceActionBurnDitamin MelandServiceAction = "BurnDitamin"
const MelandServiceActionCanBuildNFT MelandServiceAction = "CanBuildNFT"
const MelandServiceActionCheckQuestionAnswer MelandServiceAction = "CheckQuestionAnswer"
const MelandServiceActionGetInitLandAttributions MelandServiceAction = "GetInitLandAttributions"
const MelandServiceActionGetQuestionResourcesByTypes MelandServiceAction = "GetQuestionResourcesByTypes"
const MelandServiceActionGetQuestionsByTypesRandom MelandServiceAction = "GetQuestionsByTypesRandom"
const MelandServiceActionGetUserIdByAddress MelandServiceAction = "GetUserIdByAddress"
const MelandServiceActionGetUserNFTs MelandServiceAction = "GetUserNFTs"
const MelandServiceActionGetUserWeb3Profile MelandServiceAction = "GetUserWeb3Profile"

type MergeByRecipeInput struct {
	// 合成数量
	Amount int `json:"amount"`

	// 图鉴id
	RecipeId string `json:"recipeId"`

	// 合成的用户
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MergeByRecipeInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["recipeId"]; !ok || v == nil {
		return fmt.Errorf("field recipeId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MergeByRecipeInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MergeByRecipeInput(plain)
	return nil
}

type MergeByRecipeOutput map[string]interface{}

type MintNFTWithItemIdAndUserAddressInputQuality string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPEndType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPEndType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPEndType, v)
	}
	*j = PVPEndType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdAndUserAddressInputQuality) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MintNFTWithItemIdAndUserAddressInputQuality {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MintNFTWithItemIdAndUserAddressInputQuality, v)
	}
	*j = MintNFTWithItemIdAndUserAddressInputQuality(v)
	return nil
}

const MintNFTWithItemIdAndUserAddressInputQualityAdvanced MintNFTWithItemIdAndUserAddressInputQuality = "Advanced"
const MintNFTWithItemIdAndUserAddressInputQualityBasic MintNFTWithItemIdAndUserAddressInputQuality = "Basic"
const MintNFTWithItemIdAndUserAddressInputQualityEnhanced MintNFTWithItemIdAndUserAddressInputQuality = "Enhanced"
const MintNFTWithItemIdAndUserAddressInputQualitySuper MintNFTWithItemIdAndUserAddressInputQuality = "Super"
const MintNFTWithItemIdAndUserAddressInputQualityUltimate MintNFTWithItemIdAndUserAddressInputQuality = "Ultimate"

type MintNFTWithItemIdAndUserAddressInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount"`

	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId"`

	// Quality corresponds to the JSON schema field "quality".
	Quality *MintNFTWithItemIdAndUserAddressInputQuality `json:"quality,omitempty"`

	// QualityVal corresponds to the JSON schema field "qualityVal".
	QualityVal *string `json:"qualityVal,omitempty"`

	// UserAddress corresponds to the JSON schema field "userAddress".
	UserAddress string `json:"userAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdAndUserAddressInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["userAddress"]; !ok || v == nil {
		return fmt.Errorf("field userAddress: required")
	}
	type Plain MintNFTWithItemIdAndUserAddressInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdAndUserAddressInput(plain)
	return nil
}

type MintNFTWithItemIdAndUserAddressOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdAndUserAddressOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain MintNFTWithItemIdAndUserAddressOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdAndUserAddressOutput(plain)
	return nil
}

type MintNFTWithItemIdInputQuality string

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitWearingPosition) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitWearingPosition {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitWearingPosition, v)
	}
	*j = NFTTraitWearingPosition(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdInputQuality) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MintNFTWithItemIdInputQuality {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MintNFTWithItemIdInputQuality, v)
	}
	*j = MintNFTWithItemIdInputQuality(v)
	return nil
}

const MintNFTWithItemIdInputQualityAdvanced MintNFTWithItemIdInputQuality = "Advanced"
const MintNFTWithItemIdInputQualityBasic MintNFTWithItemIdInputQuality = "Basic"
const MintNFTWithItemIdInputQualityEnhanced MintNFTWithItemIdInputQuality = "Enhanced"

type DitaminProduceSource_1 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitType, v)
	}
	*j = NFTTraitType(v)
	return nil
}

type MintNFTWithItemIdInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount"`

	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId"`

	// 玩家所在的坐标landId,
	// 当mint场景是捡取掉落物时携带
	LandId int `json:"landId"`

	// Quality corresponds to the JSON schema field "quality".
	Quality *MintNFTWithItemIdInputQuality `json:"quality,omitempty"`

	// QualityVal corresponds to the JSON schema field "qualityVal".
	QualityVal *string `json:"qualityVal,omitempty"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MintNFTWithItemIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitRarity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitRarity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitRarity, v)
	}
	*j = NFTTraitRarity(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain MintNFTWithItemIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitQuality) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitQuality {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitQuality, v)
	}
	*j = NFTTraitQuality(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithMetadataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MintNFTWithMetadataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithMetadataInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitPlaceableLands) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitPlaceableLands {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitPlaceableLands, v)
	}
	*j = NFTTraitPlaceableLands(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithMetadataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain MintNFTWithMetadataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithMetadataOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitTypes, v)
	}
	*j = NFTTraitTypes(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerInfoByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userIds"]; !ok || v == nil {
		return fmt.Errorf("field userIds: required")
	}
	type Plain MultiGetPlayerInfoByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerInfoByUserIdInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiUpdateUserNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["fromLandId"]; !ok || v == nil {
		return fmt.Errorf("field fromLandId: required")
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MultiUpdateUserNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiUpdateUserNFT(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerInfoByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerInfos"]; !ok || v == nil {
		return fmt.Errorf("field playerInfos: required")
	}
	type Plain MultiGetPlayerInfoByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerInfoByUserIdOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecipeInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain RecipeInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecipeInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerUsingNftsByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userIds"]; !ok || v == nil {
		return fmt.Errorf("field userIds: required")
	}
	type Plain MultiGetPlayerUsingNftsByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerUsingNftsByUserIdInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiLandAttributionUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["occupiedLandIds"]; !ok || v == nil {
		return fmt.Errorf("field occupiedLandIds: required")
	}
	if v, ok := raw["ticketLandIds"]; !ok || v == nil {
		return fmt.Errorf("field ticketLandIds: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	if v, ok := raw["vipLandIds"]; !ok || v == nil {
		return fmt.Errorf("field vipLandIds: required")
	}
	type Plain MultiLandAttributionUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiLandAttributionUpdate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserUsingNft) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	if v, ok := raw["usingNfts"]; !ok || v == nil {
		return fmt.Errorf("field usingNfts: required")
	}
	type Plain UserUsingNft
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserUsingNft(plain)
	return nil
}

const MintNFTWithItemIdInputQualitySuper MintNFTWithItemIdInputQuality = "Super"
const MintNFTWithItemIdInputQualityUltimate MintNFTWithItemIdInputQuality = "Ultimate"

type MintNFTWithItemIdOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

type MintNFTWithMetadataInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount"`

	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata NFTMetadata_1 `json:"metadata"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type MintNFTWithMetadataOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

type MultiGetPlayerInfoByUserIdInput struct {
	// UserIds corresponds to the JSON schema field "userIds".
	UserIds []string `json:"userIds"`
}

type MultiGetPlayerInfoByUserIdOutput struct {
	// PlayerInfos corresponds to the JSON schema field "playerInfos".
	PlayerInfos []PlayerInfo `json:"playerInfos"`
}

type MultiGetPlayerUsingNftsByUserIdInput struct {
	// UserIds corresponds to the JSON schema field "userIds".
	UserIds []string `json:"userIds"`
}

type MultiGetPlayerUsingNftsByUserIdOutput struct {
	// UserUsingNfts corresponds to the JSON schema field "UserUsingNfts".
	UserUsingNfts []UserUsingNft `json:"UserUsingNfts"`
}

type MultiLandAttributionUpdate struct {
	// 消息版本号
	Etag int `json:"etag"`

	// landId = 地格坐标R*10000 + 地格坐标C
	OccupiedLandIds []int `json:"occupiedLandIds"`

	// landId = 地格坐标R*10000 + 地格坐标C
	TicketLandIds []int `json:"ticketLandIds"`

	// 归属用户id
	UserId string `json:"userId"`

	// landId = 地格坐标R*10000 + 地格坐标C
	VipLandIds []int `json:"vipLandIds"`
}

type MultiUpdateUserNFT struct {
	// 消息版本号
	Etag int `json:"etag"`

	// 来源坐标
	// 当捡取时携带且不为0
	FromLandId int `json:"fromLandId"`

	// 来源合成图鉴
	FromRecipeInfo *RecipeInfo `json:"fromRecipeInfo,omitempty"`

	// NFT信息
	Nfts []NFT `json:"nfts"`

	// 接收NFT的用户钱包地址
	RecipientBlockchainAddress *string `json:"recipientBlockchainAddress,omitempty"`

	// 发送NFT的用户钱包地址
	SenderBlockchainAddress *string `json:"senderBlockchainAddress,omitempty"`

	// 区块链交易hash
	Txn *string `json:"txn,omitempty"`

	// 归属用户id
	UserId string `json:"userId"`
}

type NFT struct {
	// NFT address
	Address string `json:"address"`

	// NFT amount
	Amount int `json:"amount"`

	// NFT 变化量
	// 默认值为0, 当某一个事件发出时,
	// 若为n<0则表示此次事件导致的nft数量减少n,
	// n>0则表示此次事件导致的nft数量增加n
	AmountOfChange int `json:"amountOfChange"`

	// NFT id
	Id string `json:"id"`

	// 该NFT是否是Meland.ai官方NFT
	IsMelandAI bool `json:"isMelandAI"`

	// 只有当isMelandAI为true时, 才存在, 否则为空字符串
	ItemId string `json:"itemId"`

	// NFT metadata info
	// 如果非第三方则必须有metadata
	// 目前的实现是, 如果是第三方NFT, 则metadata为空,
	// 直接将tokenURL返回给前端解析即可.
	// example:
	// https://nftmetadata-service-release.melandworld.com/placeable/80000031/1
	Metadata *NFTMetadata_1 `json:"metadata,omitempty"`

	// 描述当前nft存储于那条链上
	Network string `json:"network"`

	// NFT token id
	TokenId string `json:"tokenId"`

	// NFT metadata url
	// https://nftmetadata-service-release.melandworld.com/placeable/80000031/1
	TokenURL string `json:"tokenURL"`
}

// NFTAttribute 为产品定义的每个NFT的属性.
type NFTAttribute struct {
	// DisplayType corresponds to the JSON schema field "display_type".
	DisplayType *string `json:"display_type,omitempty"`

	// TraitType corresponds to the JSON schema field "trait_type".
	TraitType string `json:"trait_type"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value"`
}

// NFT metadata源信息
// https://docs.opensea.io/docs/metadata-standards
type NFTMetadata_1 struct {
	// NFT gif animation url
	AnimationUrl *string `json:"animation_url,omitempty"`

	// NFT的额外属性.
	Attributes []NFTAttribute `json:"attributes"`

	// BackgroundColor corresponds to the JSON schema field "background_color".
	BackgroundColor *string `json:"background_color,omitempty"`

	// NFT description
	Description string `json:"description"`

	// NFT 扩展url
	// 有扩展URL的NFT社区会实现规范用户点击进行跳转。
	ExternalUrl *string `json:"external_url,omitempty"`

	// NFT image data.
	Image *string `json:"image,omitempty"`

	// ImageData corresponds to the JSON schema field "image_data".
	ImageData *string `json:"image_data,omitempty"`

	// ImageUrl corresponds to the JSON schema field "image_url".
	ImageUrl *string `json:"image_url,omitempty"`

	// NFT的原始数据. 只有meland.ai的NFT才会携带
	// 基于策划的表格配置生成.
	MelandAttributes []MelandAttribute `json:"melandAttributes,omitempty"`

	// NFT name
	Name string `json:"name"`

	// Youtube video url
	YoutubeUrl *string `json:"youtube_url,omitempty"`
}

// NFT放置过期时间结构体
type NFTPlaceableTimeout struct {
	// NFT Id
	NftId string `json:"nftId"`

	// 名字（是否唯一）
	TimeoutSec int `json:"timeoutSec"`
}

// 核心技能id
type NFTTraitCoreSkillId interface{}

type NFTTraitPlaceableLands string

const NFTTraitPlaceableLandsOccupied NFTTraitPlaceableLands = "Occupied"
const NFTTraitPlaceableLandsTicket NFTTraitPlaceableLands = "Ticket"
const NFTTraitPlaceableLandsVIP NFTTraitPlaceableLands = "VIP"

type NFTTraitQuality string

const NFTTraitQualityAdvanced NFTTraitQuality = "Advanced"
const NFTTraitQualityBasic NFTTraitQuality = "Basic"
const NFTTraitQualityEnhanced NFTTraitQuality = "Enhanced"
const NFTTraitQualitySuper NFTTraitQuality = "Super"
const NFTTraitQualityUltimate NFTTraitQuality = "Ultimate"

type NFTTraitRarity string

const NFTTraitRarityCommon NFTTraitRarity = "common"
const NFTTraitRarityEpic NFTTraitRarity = "epic"
const NFTTraitRarityMythic NFTTraitRarity = "mythic"
const NFTTraitRarityRare NFTTraitRarity = "rare"
const NFTTraitRarityUnique NFTTraitRarity = "unique"

type NFTTraitSkillLevel interface{}

type NFTTraitType string

const NFTTraitTypeBow NFTTraitType = "Bow"
const NFTTraitTypeChestArmor NFTTraitType = "Chest Armor"
const NFTTraitTypeConsumable NFTTraitType = "Consumable"
const NFTTraitTypeDagger NFTTraitType = "Dagger"
const NFTTraitTypeFeetArmor NFTTraitType = "Feet Armor"
const NFTTraitTypeHandsArmor NFTTraitType = "Hands Armor"
const NFTTraitTypeHeadArmor NFTTraitType = "Head Armor"
const NFTTraitTypeLegsArmor NFTTraitType = "Legs Armor"
const NFTTraitTypeMaterial NFTTraitType = "Material"
const NFTTraitTypeMysteryBox NFTTraitType = "MysteryBox"
const NFTTraitTypePlaceable NFTTraitType = "Placeable"
const NFTTraitTypeSpear NFTTraitType = "Spear"
const NFTTraitTypeSword NFTTraitType = "Sword"
const NFTTraitTypeWearable NFTTraitType = "Wearable"

type NFTTraitTypes string

const NFTTraitTypesAttack NFTTraitTypes = "Attack"
const NFTTraitTypesAttackSpeed NFTTraitTypes = "Attack Speed"
const NFTTraitTypesCoreSkillId NFTTraitTypes = "CoreSkillId"
const NFTTraitTypesCritDamage NFTTraitTypes = "Crit Damage"
const NFTTraitTypesCritPoints NFTTraitTypes = "Crit Points"
const NFTTraitTypesDefence NFTTraitTypes = "Defence"
const NFTTraitTypesDodgePoints NFTTraitTypes = "Dodge Points"
const NFTTraitTypesGetBuff NFTTraitTypes = "Get Buff"
const NFTTraitTypesHPRecovery NFTTraitTypes = "HP Recovery"
const NFTTraitTypesHitPoints NFTTraitTypes = "Hit Points"
const NFTTraitTypesLearnRecipe NFTTraitTypes = "Learn Recipe"
const NFTTraitTypesMaxHP NFTTraitTypes = "MaxHP"
const NFTTraitTypesMoveSpeed NFTTraitTypes = "Move Speed"
const NFTTraitTypesPlaceableLands NFTTraitTypes = "Placeable Lands"
const NFTTraitTypesQuality NFTTraitTypes = "Quality"
const NFTTraitTypesRarity NFTTraitTypes = "Rarity"
const NFTTraitTypesRestoreHP NFTTraitTypes = "Restore HP"
const NFTTraitTypesSeries NFTTraitTypes = "Series"
const NFTTraitTypesSkillLevel NFTTraitTypes = "SkillLevel"
const NFTTraitTypesType NFTTraitTypes = "Type"
const NFTTraitTypesWearingPosition NFTTraitTypes = "Wearing Position"

type NFTTraitWearingPosition string

const NFTTraitWearingPositionGloves NFTTraitWearingPosition = "Gloves"
const NFTTraitWearingPositionHead NFTTraitWearingPosition = "Head"
const NFTTraitWearingPositionLowerBody NFTTraitWearingPosition = "Lower Body"
const NFTTraitWearingPositionShoes NFTTraitWearingPosition = "Shoes"
const NFTTraitWearingPositionUpperBody NFTTraitWearingPosition = "Upper Body"

type PVPEndType string

const PVPEndTypeEndTypeTie PVPEndType = "endTypeTie"
const PVPEndTypeEndTypeWin PVPEndType = "endTypeWin"

type PVPMatchEnterInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`
}

type PVPMatchEnterOutput struct {
	// Succese corresponds to the JSON schema field "succese".
	Succese bool `json:"succese"`
}

type PVPMatchLeaveInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`
}

type PVPMatchLeaveOutput struct {
	// Succese corresponds to the JSON schema field "succese".
	Succese bool `json:"succese"`
}

type PVPPKSessionStatus string

const PVPPKSessionStatusEnded PVPPKSessionStatus = "ended"
const PVPPKSessionStatusPreloading PVPPKSessionStatus = "preloading"
const PVPPKSessionStatusStarted PVPPKSessionStatus = "started"

type PVPPlayer struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Type corresponds to the JSON schema field "type".
	Type PVPUserType `json:"type"`
}

type PVPRoomPreLeaveInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`

	// RoomId corresponds to the JSON schema field "roomId".
	RoomId string `json:"roomId"`
}

type PVPRoomPreLeaveOutput struct {
	// CanLeave corresponds to the JSON schema field "canLeave".
	CanLeave bool `json:"canLeave"`
}

type PVPRoomReadyInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`

	// PvpRoomId corresponds to the JSON schema field "pvpRoomId".
	PvpRoomId string `json:"pvpRoomId"`
}

type PVPRoomReadyOutput map[string]interface{}

type PVPServiceAction string

const PVPServiceActionCreatePVPRoom PVPServiceAction = "CreatePVPRoom"
const PVPServiceActionGetCurrentPkSessionId PVPServiceAction = "GetCurrentPkSessionId"
const PVPServiceActionGetPlayerPvpProfile PVPServiceAction = "GetPlayerPvpProfile"
const PVPServiceActionGetPlayerPvpRank PVPServiceAction = "GetPlayerPvpRank"
const PVPServiceActionGetPvpHistory PVPServiceAction = "GetPvpHistory"
const PVPServiceActionPVPMatchEnter PVPServiceAction = "PVPMatchEnter"
const PVPServiceActionPVPMatchLeave PVPServiceAction = "PVPMatchLeave"
const PVPServiceActionPVPRoomPreLeave PVPServiceAction = "PVPRoomPreLeave"
const PVPServiceActionPVPRoomReady PVPServiceAction = "PVPRoomReady"
const PVPServiceActionPkSessionAgain PVPServiceAction = "PkSessionAgain"
const PVPServiceActionPkSessionDoQuestion PVPServiceAction = "PkSessionDoQuestion"
const PVPServiceActionPkSessionLoadSuccess PVPServiceAction = "PkSessionLoadSuccess"
const PVPServiceActionPkSessionUITick PVPServiceAction = "PkSessionUITick"
const PVPServiceActionPvpSurrender PVPServiceAction = "PvpSurrender"

type PVPSubscriptionEvent string

const PVPSubscriptionEventPVPMatchBegin PVPSubscriptionEvent = "PVPMatchBegin"

type PVPType string

const PVPTypePvpTypeMatch PVPType = "pvpTypeMatch"
const PVPTypePvpTypePk PVPType = "pvpTypePk"

type PVPUserType string

const PVPUserTypeGuest PVPUserType = "guest"
const PVPUserTypeUser PVPUserType = "user"

type PVPUserType_1 string

const PVPUserType_1_Guest PVPUserType_1 = "guest"
const PVPUserType_1_User PVPUserType_1 = "user"

type PageMeta struct {
	// Count corresponds to the JSON schema field "count".
	Count int `json:"count"`
}

type PkSessionAgainInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`
}

type PkSessionAgainOutput struct {
	// PkRoomId corresponds to the JSON schema field "pkRoomId".
	PkRoomId string `json:"pkRoomId"`
}

type PkSessionDoQuestionInput struct {
	// AnswerSequentialMatch corresponds to the JSON schema field
	// "answerSequentialMatch".
	AnswerSequentialMatch []string `json:"answerSequentialMatch,omitempty"`

	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId"`
}

type PkSessionDoQuestionOutput struct {
	// IsCorrect corresponds to the JSON schema field "isCorrect".
	IsCorrect bool `json:"isCorrect"`
}

type PkSessionLoadSuccessInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`
}

type PkSessionLoadSuccessOutput map[string]interface{}

type PkSessionUITickInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data"`

	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player"`
}

type PkSessionUITickOutput map[string]interface{}

type PlayerAvatar struct {
	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId"`

	// NftJson corresponds to the JSON schema field "nftJson".
	NftJson string `json:"nftJson"`

	// Pos corresponds to the JSON schema field "pos".
	Pos int `json:"pos"`
}

// 玩家死亡事件, 当玩家死亡时触发
type PlayerDeath struct {
	// 玩家死亡的附近landId
	DeathLandId int `json:"deathLandId"`

	// 造成玩家死亡的生物或用户id
	KillerId string `json:"killerId"`

	// 造成玩家死亡的生物或用户名称
	KillerName string `json:"killerName"`

	// 最后造成死亡的数值
	LastDamage float64 `json:"lastDamage"`

	// 死亡的用户id
	UserId string `json:"userId"`
}

type PlayerInfo struct {
	// Feature corresponds to the JSON schema field "feature".
	Feature string `json:"feature"`

	// Icon corresponds to the JSON schema field "icon".
	Icon string `json:"icon"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`

	// PlayerName corresponds to the JSON schema field "playerName".
	PlayerName string `json:"playerName"`

	// 角色cid (男性 1001 / 女性 1002)
	RoleCId int `json:"roleCId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type PlayerItemSocket struct {
	// Level corresponds to the JSON schema field "level".
	Level int `json:"level"`

	// Position corresponds to the JSON schema field "position".
	Position int `json:"position"`
}

// 玩家击杀怪物
type PlayerKilled struct {
	// 怪物被击杀的坐标
	KilledLandId int `json:"killedLandId"`

	// 最后一击的伤害
	LastDamage float64 `json:"lastDamage"`

	// 击杀的目标id
	TargetId string `json:"targetId"`

	// 击杀的目标名称
	TargetName string `json:"targetName"`

	// 用户id
	UserId string `json:"userId"`
}

// 玩家重生事件, 当玩家重生时, 会触发此事件
type PlayerReborn struct {
	// 重生的地格id
	RebornLandId int `json:"rebornLandId"`

	// 玩家重生类型
	Type PlayerRebornType_1 `json:"type"`

	// 重生的玩家id
	UserId string `json:"userId"`
}

type PlayerRebornType string

const PlayerRebornTypeInPlace PlayerRebornType = "in_place"
const PlayerRebornTypeMainCity PlayerRebornType = "main_city"

type PlayerRebornType_1 string

const PlayerRebornType_1_InPlace PlayerRebornType_1 = "in_place"
const PlayerRebornType_1_MainCity PlayerRebornType_1 = "main_city"

type Prefetch struct {
	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId"`

	// QuestionType corresponds to the JSON schema field "questionType".
	QuestionType QuestionType `json:"questionType"`

	// Resources corresponds to the JSON schema field "resources".
	Resources []string `json:"resources"`
}

type PvpHistory struct {
	// EndType corresponds to the JSON schema field "endType".
	EndType string `json:"endType"`

	// Loser corresponds to the JSON schema field "loser".
	Loser string `json:"loser"`

	// LoserName corresponds to the JSON schema field "loserName".
	LoserName string `json:"loserName"`

	// LoserScore corresponds to the JSON schema field "loserScore".
	LoserScore int `json:"loserScore"`

	// PvpType corresponds to the JSON schema field "pvpType".
	PvpType string `json:"pvpType"`

	// ScoreOffset corresponds to the JSON schema field "scoreOffset".
	ScoreOffset int `json:"scoreOffset"`

	// TimeSec corresponds to the JSON schema field "timeSec".
	TimeSec int `json:"timeSec"`

	// Winner corresponds to the JSON schema field "winner".
	Winner string `json:"winner"`

	// WinnerName corresponds to the JSON schema field "winnerName".
	WinnerName string `json:"winnerName"`

	// WinnerScore corresponds to the JSON schema field "winnerScore".
	WinnerScore int `json:"winnerScore"`
}

type PvpPlayerProfile struct {
	// Avatars corresponds to the JSON schema field "avatars".
	Avatars []PlayerAvatar `json:"avatars"`

	// BaseInfo corresponds to the JSON schema field "baseInfo".
	BaseInfo PlayerInfo `json:"baseInfo"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`

	// Score corresponds to the JSON schema field "score".
	Score int `json:"score"`
}

type PvpPlayerRank struct {
	// Avatars corresponds to the JSON schema field "avatars".
	Avatars []PlayerAvatar `json:"avatars"`

	// BaseInfo corresponds to the JSON schema field "baseInfo".
	BaseInfo PlayerInfo `json:"baseInfo"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`

	// Rank corresponds to the JSON schema field "rank".
	Rank int `json:"rank"`

	// Score corresponds to the JSON schema field "score".
	Score int `json:"score"`
}

type PvpSurrenderInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`
}

type PvpSurrenderOutput struct {
	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success"`
}

type Question struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// StructJSON corresponds to the JSON schema field "structJSON".
	StructJSON string `json:"structJSON"`
}

type QuestionType string

const QuestionTypeAdjustClock QuestionType = "AdjustClock"
const QuestionTypeBlockCompute QuestionType = "BlockCompute"
const QuestionTypeCageShuffle QuestionType = "CageShuffle"
const QuestionTypeCardMemory QuestionType = "CardMemory"
const QuestionTypeCuttingArt QuestionType = "CuttingArt"
const QuestionTypeHitBrick QuestionType = "HitBrick"
const QuestionTypeMatchingMouse QuestionType = "MatchingMouse"
const QuestionTypeQuickFlashMemory QuestionType = "QuickFlashMemory"
const QuestionTypeReverseMemory QuestionType = "ReverseMemory"
const QuestionTypeRotatingSilhouette QuestionType = "RotatingSilhouette"
const QuestionTypeSequenceBalloon QuestionType = "SequenceBalloon"
const QuestionTypeSingleChoice QuestionType = "SingleChoice"

type QuestionType_1 string

const QuestionType_1_AdjustClock QuestionType_1 = "AdjustClock"
const QuestionType_1_BlockCompute QuestionType_1 = "BlockCompute"
const QuestionType_1_CageShuffle QuestionType_1 = "CageShuffle"
const QuestionType_1_CardMemory QuestionType_1 = "CardMemory"
const QuestionType_1_CuttingArt QuestionType_1 = "CuttingArt"
const QuestionType_1_HitBrick QuestionType_1 = "HitBrick"
const QuestionType_1_MatchingMouse QuestionType_1 = "MatchingMouse"
const QuestionType_1_QuickFlashMemory QuestionType_1 = "QuickFlashMemory"
const QuestionType_1_ReverseMemory QuestionType_1 = "ReverseMemory"
const QuestionType_1_RotatingSilhouette QuestionType_1 = "RotatingSilhouette"
const QuestionType_1_SequenceBalloon QuestionType_1 = "SequenceBalloon"
const QuestionType_1_SingleChoice QuestionType_1 = "SingleChoice"

type RecipeInfo struct {
	// 图鉴id
	Id string `json:"id"`

	// 图鉴名称
	Name string `json:"name"`
}

type Sex string

const SexFEMALE Sex = "FEMALE"
const SexMALE Sex = "MALE"

type Sex_1 string

const Sex_1_FEMALE Sex_1 = "FEMALE"
const Sex_1_MALE Sex_1 = "MALE"

type Skill struct {
	// skill level
	Level int `json:"level"`

	// skill Id,  only key
	SkillId int `json:"skillId"`
}

type SubscriptionEvent string

const SubscriptionEventDitaminBurn SubscriptionEvent = "DitaminBurn"
const SubscriptionEventDitaminProduce SubscriptionEvent = "DitaminProduce"
const SubscriptionEventFinishQuestion SubscriptionEvent = "FinishQuestion"
const SubscriptionEventLandAttributionUpdate SubscriptionEvent = "LandAttributionUpdate"
const SubscriptionEventLandFightStatusUpdate SubscriptionEvent = "LandFightStatusUpdate"
const SubscriptionEventMELDExchange2Ditamin SubscriptionEvent = "MELDExchange2Ditamin"
const SubscriptionEventMELDFutureExchangeRateChange SubscriptionEvent = "MELDFutureExchangeRateChange"
const SubscriptionEventMELDFutureMint SubscriptionEvent = "MELDFutureMint"
const SubscriptionEventMELDFutureRelease SubscriptionEvent = "MELDFutureRelease"
const SubscriptionEventMarketplaceTrade SubscriptionEvent = "MarketplaceTrade"
const SubscriptionEventMultiLandAttributionUpdate SubscriptionEvent = "MultiLandAttributionUpdate"
const SubscriptionEventMultiUpdateUserNFT SubscriptionEvent = "MultiUpdateUserNFT"
const SubscriptionEventPlayerDeath SubscriptionEvent = "PlayerDeath"
const SubscriptionEventPlayerKilled SubscriptionEvent = "PlayerKilled"
const SubscriptionEventPlayerReborn SubscriptionEvent = "PlayerReborn"
const SubscriptionEventUnloadEquipment SubscriptionEvent = "UnloadEquipment"
const SubscriptionEventUpdateUserNFT SubscriptionEvent = "UpdateUserNFT"
const SubscriptionEventUseConsumabled SubscriptionEvent = "UseConsumabled"
const SubscriptionEventUseEquipment SubscriptionEvent = "UseEquipment"

type TemporaryToken struct {
	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt string `json:"createdAt"`

	// ExpiredAt corresponds to the JSON schema field "expiredAt".
	ExpiredAt string `json:"expiredAt"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// TemporaryTokenExtraInfo corresponds to the JSON schema field
	// "temporaryTokenExtraInfo".
	TemporaryTokenExtraInfo *TemporaryTokenExtraInfo `json:"temporaryTokenExtraInfo,omitempty"`

	// Token corresponds to the JSON schema field "token".
	Token string `json:"token"`

	// UpdatedAt corresponds to the JSON schema field "updatedAt".
	UpdatedAt string `json:"updatedAt"`

	// UsedAt corresponds to the JSON schema field "usedAt".
	UsedAt *string `json:"usedAt,omitempty"`
}

type TemporaryTokenExtraInfo struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type UnloadEquipment struct {
	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId"`

	// 用户id
	UserId string `json:"userId"`
}

// 更新用户的NFT
// 可能是添加或者数量变更.
type UpdateUserNFT struct {
	// 消息版本号
	Etag int `json:"etag"`

	// 来源坐标
	// 当捡取时携带且不为0
	FromLandId int `json:"fromLandId"`

	// NFT信息
	Nft NFT `json:"nft"`

	// 接收NFT的用户钱包地址
	RecipientBlockchainAddress *string `json:"recipientBlockchainAddress,omitempty"`

	// 发送NFT的用户钱包地址
	SenderBlockchainAddress *string `json:"senderBlockchainAddress,omitempty"`

	// 区块链交易hash
	Txn *string `json:"txn,omitempty"`

	// 归属用户id
	UserId string `json:"userId"`
}

type UpgradePlayerItemSocketsInput struct {
	// ItemSockets corresponds to the JSON schema field "itemSockets".
	ItemSockets []PlayerItemSocket `json:"itemSockets"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type UpgradePlayerItemSocketsOutput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type UseConsumableInput struct {
	// 消耗品的数量
	Amount int `json:"amount"`

	// 使用消耗品的坐标
	LandId int `json:"landId"`

	// 消耗品的id
	NftId string `json:"nftId"`

	// 使用消耗品的用户
	UserId string `json:"userId"`
}

type UseConsumableOutput struct {
	// 消耗品的数量
	Amount int `json:"amount"`

	// 消耗品的id
	NftId string `json:"nftId"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success"`

	// 使用消耗品的用户
	UserId string `json:"userId"`
}

type UseConsumabled struct {
	// 消耗品的数量
	Amount int `json:"amount"`

	// 消息版本号
	Etag int `json:"etag"`

	// 使用消耗品的坐标
	LandId int `json:"landId"`

	// Nft corresponds to the JSON schema field "nft".
	Nft NFT `json:"nft"`

	// 使用消耗品的用户
	UserId string `json:"userId"`
}

type UseEquipment struct {
	// 装备位置 对时装和装备有效
	AvatarPos int `json:"avatarPos"`

	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId"`

	// 用户id
	UserId string `json:"userId"`
}

type User struct {
	// Avatar corresponds to the JSON schema field "avatar".
	Avatar string `json:"avatar"`

	// Email corresponds to the JSON schema field "email".
	Email string `json:"email"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Mobile corresponds to the JSON schema field "mobile".
	Mobile string `json:"mobile"`

	// Nickname corresponds to the JSON schema field "nickname".
	Nickname string `json:"nickname"`

	// Realname corresponds to the JSON schema field "realname".
	Realname string `json:"realname"`

	// SchoolId corresponds to the JSON schema field "schoolId".
	SchoolId string `json:"schoolId"`

	// Sex corresponds to the JSON schema field "sex".
	Sex Sex_1 `json:"sex"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username"`

	// Usertype corresponds to the JSON schema field "usertype".
	Usertype UserType `json:"usertype"`
}

// 玩家地格信息数据结构
type UserLandInfo struct {
	// landId = 地格坐标R*10000 + 地格坐标C
	OccupiedLands []int `json:"occupiedLands"`

	// landId = 地格坐标R*10000 + 地格坐标C
	TicketLands []int `json:"ticketLands"`

	// landId = 地格坐标R*10000 + 地格坐标C
	VipLands []int `json:"vipLands"`
}

type UserStakeAdd struct {
	// AmountOfMELD corresponds to the JSON schema field "amountOfMELD".
	AmountOfMELD string `json:"amountOfMELD"`

	// 消息版本号
	Etag int `json:"etag"`

	// StakeLevel corresponds to the JSON schema field "stakeLevel".
	StakeLevel string `json:"stakeLevel"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

type UserStakeClaim struct {
	// AmountOfMELD corresponds to the JSON schema field "amountOfMELD".
	AmountOfMELD string `json:"amountOfMELD"`

	// 消息版本号
	Etag int `json:"etag"`

	// StakeLevel corresponds to the JSON schema field "stakeLevel".
	StakeLevel string `json:"stakeLevel"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

type UserStakeExpire struct {
	// AmountOfMELD corresponds to the JSON schema field "amountOfMELD".
	AmountOfMELD string `json:"amountOfMELD"`

	// 消息版本号
	Etag int `json:"etag"`

	// StakeLevel corresponds to the JSON schema field "stakeLevel".
	StakeLevel string `json:"stakeLevel"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

type UserStakeHarvest struct {
	// 消息版本号
	Etag int `json:"etag"`

	// HarvestAmountOfMELD corresponds to the JSON schema field "harvestAmountOfMELD".
	HarvestAmountOfMELD string `json:"harvestAmountOfMELD"`

	// UserBlockchainAddress corresponds to the JSON schema field
	// "userBlockchainAddress".
	UserBlockchainAddress string `json:"userBlockchainAddress"`
}

type UserType string

const UserTypeMANAGER UserType = "MANAGER"
const UserTypeSTUDENT UserType = "STUDENT"
const UserTypeTEACHER UserType = "TEACHER"

type UserType_1 string

const UserType_1_MANAGER UserType_1 = "MANAGER"
const UserType_1_STUDENT UserType_1 = "STUDENT"
const UserType_1_TEACHER UserType_1 = "TEACHER"

type UserUsingNft struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`

	// UsingNfts corresponds to the JSON schema field "usingNfts".
	UsingNfts []UsingNFT `json:"usingNfts"`
}

type UsingNFT struct {
	// 装备位置 对时装和装备有效
	AvatarPos int `json:"avatarPos"`

	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId"`

	// 用户id
	UserId string `json:"userId"`
}

type Web3ServiceAction string

const Web3ServiceActionBatchMintNFTWithItemId Web3ServiceAction = "BatchMintNFTWithItemId"
const Web3ServiceActionBurnNFT Web3ServiceAction = "BurnNFT"
const Web3ServiceActionGetUserNFTsByUserIdAndAddress Web3ServiceAction = "GetUserNFTsByUserIdAndAddress"
const Web3ServiceActionGetUserRecipes Web3ServiceAction = "GetUserRecipes"
const Web3ServiceActionMergeByRecipe Web3ServiceAction = "MergeByRecipe"
const Web3ServiceActionMintNFTWithItemId Web3ServiceAction = "MintNFTWithItemId"
const Web3ServiceActionMintNFTWithItemIdAndUserAddress Web3ServiceAction = "MintNFTWithItemIdAndUserAddress"
const Web3ServiceActionMintNFTWithMetadata Web3ServiceAction = "MintNFTWithMetadata"
const Web3ServiceActionUseConsumable Web3ServiceAction = "UseConsumable"

var enumValues_AppId = []interface{}{
	"bellplanet-account",
	"bellplanet-game",
	"meland-service",
	"pvp-service",
	"web3-service",
}
var enumValues_AuthUserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_BatchMintNFTWithItemIdInputQualitysElem = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}
var enumValues_DitaminBurnSource = []interface{}{
	"build3drNFT",
	"buildNFT",
	"buyEnergy",
	"craft",
	"exchange",
}
var enumValues_DitaminBurnSource_1 = []interface{}{
	"build3drNFT",
	"buildNFT",
	"buyEnergy",
	"craft",
	"exchange",
}
var enumValues_DitaminBurnSource_2 = []interface{}{
	"build3drNFT",
	"buildNFT",
	"buyEnergy",
	"craft",
	"exchange",
}
var enumValues_DitaminProduceSource = []interface{}{
	"attackFinlish",
	"deposit",
	"harvest",
}
var enumValues_DitaminProduceSource_1 = []interface{}{
	"attackFinlish",
	"deposit",
	"harvest",
}
var enumValues_GameAccountServiceAction = []interface{}{
	"GetPlayerInfoByUserId",
	"GetPlayerItemSockets",
	"GetPlayerUsingNftsByUserId",
	"MultiGetPlayerInfoByUserId",
	"MultiGetPlayerUsingNftsByUserId",
	"UpgradePlayerItemSockets",
}
var enumValues_GameServiceAction = []interface{}{
	"LandUsingSkill",
}
var enumValues_LandFightStatus = []interface{}{
	"attacked",
	"normal",
}
var enumValues_LandFightStatus_1 = []interface{}{
	"attacked",
	"normal",
}
var enumValues_LandStatus = []interface{}{
	"Nill",
	"Occupied",
	"Ticket",
	"Unoccupied",
	"VIP",
}
var enumValues_LandStatus_1 = []interface{}{
	"Nill",
	"Occupied",
	"Ticket",
	"Unoccupied",
	"VIP",
}
var enumValues_MelandServiceAction = []interface{}{
	"BurnDitamin",
	"CanBuildNFT",
	"CheckQuestionAnswer",
	"GetInitLandAttributions",
	"GetQuestionResourcesByTypes",
	"GetQuestionsByTypesRandom",
	"GetUserIdByAddress",
	"GetUserNFTs",
	"GetUserWeb3Profile",
}
var enumValues_MintNFTWithItemIdAndUserAddressInputQuality = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}
var enumValues_MintNFTWithItemIdInputQuality = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}
var enumValues_NFTTraitPlaceableLands = []interface{}{
	"Occupied",
	"Ticket",
	"VIP",
}
var enumValues_NFTTraitQuality = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}
var enumValues_NFTTraitRarity = []interface{}{
	"common",
	"epic",
	"mythic",
	"rare",
	"unique",
}
var enumValues_NFTTraitType = []interface{}{
	"Bow",
	"Chest Armor",
	"Consumable",
	"Dagger",
	"Feet Armor",
	"Hands Armor",
	"Head Armor",
	"Legs Armor",
	"Material",
	"MysteryBox",
	"Placeable",
	"Spear",
	"Sword",
	"Wearable",
}
var enumValues_NFTTraitTypes = []interface{}{
	"Attack",
	"Attack Speed",
	"CoreSkillId",
	"Crit Damage",
	"Crit Points",
	"Defence",
	"Dodge Points",
	"Get Buff",
	"HP Recovery",
	"Hit Points",
	"Learn Recipe",
	"MaxHP",
	"Move Speed",
	"Placeable Lands",
	"Quality",
	"Rarity",
	"Restore HP",
	"Series",
	"SkillLevel",
	"Type",
	"Wearing Position",
}
var enumValues_NFTTraitWearingPosition = []interface{}{
	"Gloves",
	"Head",
	"Lower Body",
	"Shoes",
	"Upper Body",
}
var enumValues_PVPEndType = []interface{}{
	"endTypeTie",
	"endTypeWin",
}
var enumValues_PVPPKSessionStatus = []interface{}{
	"ended",
	"preloading",
	"started",
}
var enumValues_PVPServiceAction = []interface{}{
	"CreatePVPRoom",
	"GetCurrentPkSessionId",
	"GetPlayerPvpProfile",
	"GetPlayerPvpRank",
	"GetPvpHistory",
	"PVPMatchEnter",
	"PVPMatchLeave",
	"PVPRoomPreLeave",
	"PVPRoomReady",
	"PkSessionAgain",
	"PkSessionDoQuestion",
	"PkSessionLoadSuccess",
	"PkSessionUITick",
	"PvpSurrender",
}
var enumValues_PVPSubscriptionEvent = []interface{}{
	"PVPMatchBegin",
}
var enumValues_PVPType = []interface{}{
	"pvpTypeMatch",
	"pvpTypePk",
}
var enumValues_PVPUserType = []interface{}{
	"guest",
	"user",
}
var enumValues_PVPUserType_1 = []interface{}{
	"guest",
	"user",
}
var enumValues_PlayerRebornType = []interface{}{
	"in_place",
	"main_city",
}
var enumValues_PlayerRebornType_1 = []interface{}{
	"in_place",
	"main_city",
}
var enumValues_QuestionType = []interface{}{
	"AdjustClock",
	"BlockCompute",
	"CageShuffle",
	"CardMemory",
	"CuttingArt",
	"HitBrick",
	"MatchingMouse",
	"QuickFlashMemory",
	"ReverseMemory",
	"RotatingSilhouette",
	"SequenceBalloon",
	"SingleChoice",
}
var enumValues_QuestionType_1 = []interface{}{
	"AdjustClock",
	"BlockCompute",
	"CageShuffle",
	"CardMemory",
	"CuttingArt",
	"HitBrick",
	"MatchingMouse",
	"QuickFlashMemory",
	"ReverseMemory",
	"RotatingSilhouette",
	"SequenceBalloon",
	"SingleChoice",
}
var enumValues_Sex = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_Sex_1 = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_SubscriptionEvent = []interface{}{
	"DitaminBurn",
	"DitaminProduce",
	"FinishQuestion",
	"LandAttributionUpdate",
	"LandFightStatusUpdate",
	"MELDExchange2Ditamin",
	"MELDFutureExchangeRateChange",
	"MELDFutureMint",
	"MELDFutureRelease",
	"MarketplaceTrade",
	"MultiLandAttributionUpdate",
	"MultiUpdateUserNFT",
	"PlayerDeath",
	"PlayerKilled",
	"PlayerReborn",
	"UnloadEquipment",
	"UpdateUserNFT",
	"UseConsumabled",
	"UseEquipment",
}
var enumValues_UserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_UserType_1 = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_Web3ServiceAction = []interface{}{
	"BatchMintNFTWithItemId",
	"BurnNFT",
	"GetUserNFTsByUserIdAndAddress",
	"GetUserRecipes",
	"MergeByRecipe",
	"MintNFTWithItemId",
	"MintNFTWithItemIdAndUserAddress",
	"MintNFTWithMetadata",
	"UseConsumable",
}
