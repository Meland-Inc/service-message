// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "fmt"
import "reflect"
import "encoding/json"

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitPlaceableLands) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitPlaceableLands {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitPlaceableLands, v)
	}
	*j = NFTTraitPlaceableLands(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Web3ServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Web3ServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Web3ServiceAction, v)
	}
	*j = Web3ServiceAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppId) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppId {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppId, v)
	}
	*j = AppId(v)
	return nil
}

const AppIdBellplanetGame AppId = "bellplanet-game"
const AppIdMelandService AppId = "meland-service"
const AppIdWeb3Service AppId = "web3-service"

type AuthUserType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType_1, v)
	}
	*j = UserType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthUserType, v)
	}
	*j = AuthUserType(v)
	return nil
}

const AuthUserTypeMANAGER AuthUserType = "MANAGER"
const AuthUserTypeSTUDENT AuthUserType = "STUDENT"
const AuthUserTypeTEACHER AuthUserType = "TEACHER"

type Auth struct {
	// AccessToken corresponds to the JSON schema field "accessToken".
	AccessToken string `json:"accessToken"`

	// UserType corresponds to the JSON schema field "userType".
	UserType *AuthUserType `json:"userType,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Auth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["accessToken"]; !ok || v == nil {
		return fmt.Errorf("field accessToken: required")
	}
	type Plain Auth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Auth(plain)
	return nil
}

type Int321 int

type BatchMintNFTWithItemId struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []Int321 `json:"amounts"`

	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// 需要mint的所有的itemId
	ItemIds []string `json:"itemIds"`

	// 所有的品质
	// index和itemIds一一对应
	QualityVals []string `json:"qualityVals"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTWithItemId) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amounts"]; !ok || v == nil {
		return fmt.Errorf("field amounts: required")
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemIds"]; !ok || v == nil {
		return fmt.Errorf("field itemIds: required")
	}
	if v, ok := raw["qualityVals"]; !ok || v == nil {
		return fmt.Errorf("field qualityVals: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain BatchMintNFTWithItemId
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchMintNFTWithItemId(plain)
	return nil
}

type BatchMintNFTWithItemIdOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTWithItemIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain BatchMintNFTWithItemIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchMintNFTWithItemIdOutput(plain)
	return nil
}

type BurnDitaminInput struct {
	// 需要燃烧的ditamin数量
	Amount string `json:"amount"`

	// 燃烧的原因
	Remark string `json:"remark"`

	// 燃烧的hash id
	// 用来防止重复燃烧, 每次燃烧调用方需要生成一个txHash.
	// 如果txHash重复, 则不会重复燃烧
	TxHash string `json:"txHash"`

	// 需要燃烧的用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnDitaminInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["remark"]; !ok || v == nil {
		return fmt.Errorf("field remark: required")
	}
	if v, ok := raw["txHash"]; !ok || v == nil {
		return fmt.Errorf("field txHash: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain BurnDitaminInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnDitaminInput(plain)
	return nil
}

type BurnDitaminOutput struct {
	// 是否燃烧成功
	BurnSuccess bool `json:"burnSuccess"`

	// 如果燃烧失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnDitaminOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["burnSuccess"]; !ok || v == nil {
		return fmt.Errorf("field burnSuccess: required")
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason: required")
	}
	type Plain BurnDitaminOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnDitaminOutput(plain)
	return nil
}

type CanBuildNFTInput struct {
	// 实体存活时间，对第三方NFT有效, 单位(秒)
	AliveTimeSec Int321 `json:"aliveTimeSec"`

	// NFT Id
	NftId string `json:"nftId"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["aliveTimeSec"]; !ok || v == nil {
		return fmt.Errorf("field aliveTimeSec: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain CanBuildNFTInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTInput(plain)
	return nil
}

type CanBuildNFTOutput struct {
	// CanBuild corresponds to the JSON schema field "canBuild".
	CanBuild bool `json:"canBuild"`

	// 消息版本号
	Etag Int321 `json:"etag"`

	// NFT id
	NftId string `json:"nftId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["canBuild"]; !ok || v == nil {
		return fmt.Errorf("field canBuild: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	type Plain CanBuildNFTOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTOutput(plain)
	return nil
}

type GameServiceAction string

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserGameDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UserGameDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserGameDataOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GameServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GameServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GameServiceAction, v)
	}
	*j = GameServiceAction(v)
	return nil
}

const GameServiceActionLandUsingSkill GameServiceAction = "LandUsingSkill"

type GetUserNFTsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserNFTsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserGameDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UserGameDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserGameDataInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTAttribute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trait_type"]; !ok || v == nil {
		return fmt.Errorf("field trait_type: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain NFTAttribute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTAttribute(plain)
	return nil
}

// 有一些配置表格的数据不希望显示在opensea中,
// 但是为了方便统一解析。
// 生成到这个表格中.
type MelandAttribute struct {
	// TraitType corresponds to the JSON schema field "trait_type".
	TraitType string `json:"trait_type"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MelandAttribute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trait_type"]; !ok || v == nil {
		return fmt.Errorf("field trait_type: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain MelandAttribute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MelandAttribute(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *User) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatar"]; !ok || v == nil {
		return fmt.Errorf("field avatar: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["mobile"]; !ok || v == nil {
		return fmt.Errorf("field mobile: required")
	}
	if v, ok := raw["nickname"]; !ok || v == nil {
		return fmt.Errorf("field nickname: required")
	}
	if v, ok := raw["realname"]; !ok || v == nil {
		return fmt.Errorf("field realname: required")
	}
	if v, ok := raw["schoolId"]; !ok || v == nil {
		return fmt.Errorf("field schoolId: required")
	}
	if v, ok := raw["sex"]; !ok || v == nil {
		return fmt.Errorf("field sex: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username: required")
	}
	if v, ok := raw["usertype"]; !ok || v == nil {
		return fmt.Errorf("field usertype: required")
	}
	type Plain User
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = User(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTMetadata_1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["attributes"]; !ok || v == nil {
		return fmt.Errorf("field attributes: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain NFTMetadata_1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTMetadata_1(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType, v)
	}
	*j = UserType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["isMelandAI"]; !ok || v == nil {
		return fmt.Errorf("field isMelandAI: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata: required")
	}
	if v, ok := raw["network"]; !ok || v == nil {
		return fmt.Errorf("field network: required")
	}
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId: required")
	}
	if v, ok := raw["tokenURL"]; !ok || v == nil {
		return fmt.Errorf("field tokenURL: required")
	}
	type Plain NFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFT(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex_1, v)
	}
	*j = Sex_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTPlaceableTimeout) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId: required")
	}
	if v, ok := raw["timeoutSec"]; !ok || v == nil {
		return fmt.Errorf("field timeoutSec: required")
	}
	type Plain NFTPlaceableTimeout
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTPlaceableTimeout(plain)
	return nil
}

type GetUserNFTsOutput struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// user all nfts
	Nfts []NFT `json:"nfts"`

	// NFT放置过期时间表
	PlaceableTimeouts []NFTPlaceableTimeout `json:"placeableTimeouts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts: required")
	}
	if v, ok := raw["placeableTimeouts"]; !ok || v == nil {
		return fmt.Errorf("field placeableTimeouts: required")
	}
	type Plain GetUserNFTsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsOutput(plain)
	return nil
}

type GetUserRecipesInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRecipesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserRecipesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRecipesInput(plain)
	return nil
}

type GetUserRecipesOutput struct {
	// RecipeIds corresponds to the JSON schema field "recipeIds".
	RecipeIds []string `json:"recipeIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRecipesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["recipeIds"]; !ok || v == nil {
		return fmt.Errorf("field recipeIds: required")
	}
	type Plain GetUserRecipesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRecipesOutput(plain)
	return nil
}

type GetUserWeb3ProfileInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserWeb3ProfileInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain GetUserWeb3ProfileInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserWeb3ProfileInput(plain)
	return nil
}

type GetUserWeb3ProfileOutput struct {
	// BlockchainAddress corresponds to the JSON schema field "blockchainAddress".
	BlockchainAddress string `json:"blockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserWeb3ProfileOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field blockchainAddress: required")
	}
	type Plain GetUserWeb3ProfileOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserWeb3ProfileOutput(plain)
	return nil
}

type Int32 int

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateUserNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nft"]; !ok || v == nil {
		return fmt.Errorf("field nft: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain UpdateUserNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpdateUserNFT(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserLandInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["occupiedLands"]; !ok || v == nil {
		return fmt.Errorf("field occupiedLands: required")
	}
	if v, ok := raw["ticketLands"]; !ok || v == nil {
		return fmt.Errorf("field ticketLands: required")
	}
	if v, ok := raw["vipLands"]; !ok || v == nil {
		return fmt.Errorf("field vipLands: required")
	}
	type Plain UserLandInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserLandInfo(plain)
	return nil
}

// 玩家地格信息 userId = UserLandInfo
type InitLandAttributionLandInfos map[string]UserLandInfo

type InitLandAttribution struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// 玩家地格信息 userId = UserLandInfo
	LandInfos InitLandAttributionLandInfos `json:"landInfos"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InitLandAttribution) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landInfos"]; !ok || v == nil {
		return fmt.Errorf("field landInfos: required")
	}
	type Plain InitLandAttribution
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = InitLandAttribution(plain)
	return nil
}

type Int322 int

type LandStatus string

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["createdAt"]; !ok || v == nil {
		return fmt.Errorf("field createdAt: required")
	}
	if v, ok := raw["expiredAt"]; !ok || v == nil {
		return fmt.Errorf("field expiredAt: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["token"]; !ok || v == nil {
		return fmt.Errorf("field token: required")
	}
	if v, ok := raw["updatedAt"]; !ok || v == nil {
		return fmt.Errorf("field updatedAt: required")
	}
	type Plain TemporaryToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryToken(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandStatus, v)
	}
	*j = LandStatus(v)
	return nil
}

const LandStatusNill LandStatus = "nill"
const LandStatusOccupied LandStatus = "occupied"
const LandStatusTicket LandStatus = "ticket"
const LandStatusUnoccupied LandStatus = "unoccupied"
const LandStatusVip LandStatus = "vip"

type LandAttributionUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// landId = 地格坐标R*10000 + 地格坐标C
	LandId Int32 `json:"landId"`

	// 地格新的归属状态
	// unoccupied || occupied || ticket || vip
	LandStatus LandStatus `json:"landStatus"`

	// 归属用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandAttributionUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["landStatus"]; !ok || v == nil {
		return fmt.Errorf("field landStatus: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandAttributionUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandAttributionUpdate(plain)
	return nil
}

type LandFightStatus string

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryTokenExtraInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain TemporaryTokenExtraInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryTokenExtraInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandFightStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandFightStatus, v)
	}
	*j = LandFightStatus(v)
	return nil
}

const LandFightStatusAttacked LandFightStatus = "attacked"
const LandFightStatusNormal LandFightStatus = "normal"

type LandFightStatus_1 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionEvent) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubscriptionEvent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubscriptionEvent, v)
	}
	*j = SubscriptionEvent(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatus_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandFightStatus_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandFightStatus_1, v)
	}
	*j = LandFightStatus_1(v)
	return nil
}

const LandFightStatus_1_Attacked LandFightStatus_1 = "attacked"
const LandFightStatus_1_Normal LandFightStatus_1 = "normal"

type LandFightStatusUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// 状态 attacked || normal
	FightStatus LandFightStatus_1 `json:"fightStatus"`

	// landId = 地格坐标R*10000 + 地格坐标C
	LandId Int32 `json:"landId"`

	// 进攻地块的用户id
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandFightStatusUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["fightStatus"]; !ok || v == nil {
		return fmt.Errorf("field fightStatus: required")
	}
	if v, ok := raw["landId"]; !ok || v == nil {
		return fmt.Errorf("field landId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandFightStatusUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandFightStatusUpdate(plain)
	return nil
}

type LandStatus_1 string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex, v)
	}
	*j = Sex(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandStatus_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandStatus_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandStatus_1, v)
	}
	*j = LandStatus_1(v)
	return nil
}

const LandStatus_1_Nill LandStatus_1 = "nill"
const LandStatus_1_Occupied LandStatus_1 = "occupied"
const LandStatus_1_Ticket LandStatus_1 = "ticket"
const LandStatus_1_Unoccupied LandStatus_1 = "unoccupied"
const LandStatus_1_Vip LandStatus_1 = "vip"

// 攻占地格 请求地格中产生效果的skill
type LandUsingSkillInput struct {
	// 消息版本号
	Etag Int322 `json:"etag"`

	// 地格ID
	TileId Int322 `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillInput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PageMeta) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		return fmt.Errorf("field count: required")
	}
	type Plain PageMeta
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PageMeta(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Skill) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level: required")
	}
	if v, ok := raw["skillId"]; !ok || v == nil {
		return fmt.Errorf("field skillId: required")
	}
	type Plain Skill
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Skill(plain)
	return nil
}

// 攻占地格 请求地格skill返回
type LandUsingSkillOutput struct {
	// 消息版本号
	Etag Int322 `json:"etag"`

	// Skill List
	SkillList []Skill `json:"skillList"`

	// 地格ID
	TileId Int322 `json:"tileId"`

	// 攻占者ID
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["skillList"]; !ok || v == nil {
		return fmt.Errorf("field skillList: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain LandUsingSkillOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillOutput(plain)
	return nil
}

type MelandServiceAction string

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitType, v)
	}
	*j = NFTTraitType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MelandServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MelandServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MelandServiceAction, v)
	}
	*j = MelandServiceAction(v)
	return nil
}

const MelandServiceActionBurnDitamin MelandServiceAction = "BurnDitamin"
const MelandServiceActionCanBuildNFT MelandServiceAction = "CanBuildNFT"
const MelandServiceActionGetInitLandAttributions MelandServiceAction = "GetInitLandAttributions"
const MelandServiceActionGetUserNFTs MelandServiceAction = "GetUserNFTs"
const MelandServiceActionGetUserWeb3Profile MelandServiceAction = "GetUserWeb3Profile"

type MergeByRecipeInput struct {
	// 合成数量
	Amount float64 `json:"amount"`

	// 图鉴id
	RecipeId string `json:"recipeId"`

	// 合成的用户
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MergeByRecipeInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["recipeId"]; !ok || v == nil {
		return fmt.Errorf("field recipeId: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MergeByRecipeInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MergeByRecipeInput(plain)
	return nil
}

type MergeByRecipeOutput map[string]interface{}

type MintNFTWithItemIdInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount Int321 `json:"amount"`

	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId"`

	// QualityVal corresponds to the JSON schema field "qualityVal".
	QualityVal string `json:"qualityVal"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["qualityVal"]; !ok || v == nil {
		return fmt.Errorf("field qualityVal: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MintNFTWithItemIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdInput(plain)
	return nil
}

type MintNFTWithItemIdOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithItemIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain MintNFTWithItemIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithItemIdOutput(plain)
	return nil
}

type MintNFTWithMetadataInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount Int321 `json:"amount"`

	// Async corresponds to the JSON schema field "async".
	Async bool `json:"async"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata NFTMetadata_1 `json:"metadata"`

	// ToUserId corresponds to the JSON schema field "toUserId".
	ToUserId string `json:"toUserId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithMetadataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["async"]; !ok || v == nil {
		return fmt.Errorf("field async: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata: required")
	}
	if v, ok := raw["toUserId"]; !ok || v == nil {
		return fmt.Errorf("field toUserId: required")
	}
	type Plain MintNFTWithMetadataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithMetadataInput(plain)
	return nil
}

type MintNFTWithMetadataOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithMetadataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId: required")
	}
	type Plain MintNFTWithMetadataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithMetadataOutput(plain)
	return nil
}

type MultiLandAttributionUpdate struct {
	// 消息版本号
	Etag Int32 `json:"etag"`

	// OccupiedLandIds corresponds to the JSON schema field "occupiedLandIds".
	OccupiedLandIds []Int32 `json:"occupiedLandIds"`

	// TicketLandIds corresponds to the JSON schema field "ticketLandIds".
	TicketLandIds []Int32 `json:"ticketLandIds"`

	// 归属用户id
	UserId string `json:"userId"`

	// landId = 地格坐标R*10000 + 地格坐标C
	VipLandIds []Int32 `json:"vipLandIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiLandAttributionUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["occupiedLandIds"]; !ok || v == nil {
		return fmt.Errorf("field occupiedLandIds: required")
	}
	if v, ok := raw["ticketLandIds"]; !ok || v == nil {
		return fmt.Errorf("field ticketLandIds: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	if v, ok := raw["vipLandIds"]; !ok || v == nil {
		return fmt.Errorf("field vipLandIds: required")
	}
	type Plain MultiLandAttributionUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiLandAttributionUpdate(plain)
	return nil
}

type AppId string

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiUpdateUserNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag: required")
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId: required")
	}
	type Plain MultiUpdateUserNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiUpdateUserNFT(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitRarity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitRarity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitRarity, v)
	}
	*j = NFTTraitRarity(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitQuality) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitQuality {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitQuality, v)
	}
	*j = NFTTraitQuality(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitTypes, v)
	}
	*j = NFTTraitTypes(v)
	return nil
}

type MultiUpdateUserNFT struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// NFT信息
	Nfts []NFT `json:"nfts"`

	// 归属用户id
	UserId string `json:"userId"`
}

type NFT struct {
	// NFT address
	Address string `json:"address"`

	// NFT amount
	Amount Int321 `json:"amount"`

	// NFT id
	Id string `json:"id"`

	// 该NFT是否是Meland.ai官方NFT
	IsMelandAI bool `json:"isMelandAI"`

	// 只有当isMelandAI为true时, 才存在, 否则为空字符串
	ItemId string `json:"itemId"`

	// NFT metadata info
	// 目前的实现是, 如果是第三方NFT, 则metadata为空,
	// 直接将tokenURL返回给前端解析即可.
	// example:
	// https://nftmetadata-service-release.melandworld.com/placeable/80000031/1
	Metadata NFTMetadata_1 `json:"metadata"`

	// 描述当前nft存储于那条链上
	Network string `json:"network"`

	// NFT token id
	TokenId string `json:"tokenId"`

	// NFT metadata url
	// https://nftmetadata-service-release.melandworld.com/placeable/80000031/1
	TokenURL string `json:"tokenURL"`
}

// NFTAttribute 为产品定义的每个NFT的属性.
type NFTAttribute struct {
	// DisplayType corresponds to the JSON schema field "display_type".
	DisplayType *string `json:"display_type,omitempty"`

	// TraitType corresponds to the JSON schema field "trait_type".
	TraitType string `json:"trait_type"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value"`
}

// NFT metadata源信息
// https://docs.opensea.io/docs/metadata-standards
type NFTMetadata_1 struct {
	// NFT gif animation url
	AnimationUrl *string `json:"animation_url,omitempty"`

	// NFT的额外属性.
	Attributes []NFTAttribute `json:"attributes"`

	// BackgroundColor corresponds to the JSON schema field "background_color".
	BackgroundColor *string `json:"background_color,omitempty"`

	// NFT description
	Description string `json:"description"`

	// NFT 扩展url
	// 有扩展URL的NFT社区会实现规范用户点击进行跳转。
	ExternalUrl *string `json:"external_url,omitempty"`

	// NFT image data.
	Image *string `json:"image,omitempty"`

	// ImageData corresponds to the JSON schema field "image_data".
	ImageData *string `json:"image_data,omitempty"`

	// ImageUrl corresponds to the JSON schema field "image_url".
	ImageUrl *string `json:"image_url,omitempty"`

	// NFT的原始数据. 只有meland.ai的NFT才会携带
	// 基于策划的表格配置生成.
	MelandAttributes []MelandAttribute `json:"melandAttributes,omitempty"`

	// NFT name
	Name string `json:"name"`

	// Youtube video url
	YoutubeUrl *string `json:"youtube_url,omitempty"`
}

// NFT放置过期时间结构体
type NFTPlaceableTimeout struct {
	// NFT Id
	NftId string `json:"nftId"`

	// 名字（是否唯一）
	TimeoutSec Int321 `json:"timeoutSec"`
}

// 核心技能id
type NFTTraitCoreSkillId interface{}

type NFTTraitPlaceableLands string

const NFTTraitPlaceableLandsOccupied NFTTraitPlaceableLands = "Occupied"
const NFTTraitPlaceableLandsTicket NFTTraitPlaceableLands = "Ticket"
const NFTTraitPlaceableLandsVIP NFTTraitPlaceableLands = "VIP"

type NFTTraitQuality string

const NFTTraitQualityAdvanced NFTTraitQuality = "Advanced"
const NFTTraitQualityBasic NFTTraitQuality = "Basic"
const NFTTraitQualityEnhanced NFTTraitQuality = "Enhanced"
const NFTTraitQualitySuper NFTTraitQuality = "Super"
const NFTTraitQualityUltimate NFTTraitQuality = "Ultimate"

type NFTTraitRarity string

const NFTTraitRarityCommon NFTTraitRarity = "common"
const NFTTraitRarityEpic NFTTraitRarity = "epic"
const NFTTraitRarityMythic NFTTraitRarity = "mythic"
const NFTTraitRarityRare NFTTraitRarity = "rare"
const NFTTraitRarityUnique NFTTraitRarity = "unique"

type NFTTraitSkillLevel interface{}

type NFTTraitType string

const NFTTraitTypeBow NFTTraitType = "Bow"
const NFTTraitTypeChestArmor NFTTraitType = "Chest Armor"
const NFTTraitTypeConsumable NFTTraitType = "Consumable"
const NFTTraitTypeDagger NFTTraitType = "Dagger"
const NFTTraitTypeFeetArmor NFTTraitType = "Feet Armor"
const NFTTraitTypeHandsArmor NFTTraitType = "Hands Armor"
const NFTTraitTypeHeadArmor NFTTraitType = "Head Armor"
const NFTTraitTypeLegsArmor NFTTraitType = "Legs Armor"
const NFTTraitTypeMaterial NFTTraitType = "Material"
const NFTTraitTypeMysteryBox NFTTraitType = "MysteryBox"
const NFTTraitTypePlaceable NFTTraitType = "Placeable"
const NFTTraitTypeSpear NFTTraitType = "Spear"
const NFTTraitTypeSword NFTTraitType = "Sword"

type NFTTraitTypes string

const NFTTraitTypesAttack NFTTraitTypes = "Attack"
const NFTTraitTypesAttackSpeed NFTTraitTypes = "Attack Speed"
const NFTTraitTypesCoreSkillId NFTTraitTypes = "CoreSkillId"
const NFTTraitTypesCritDamage NFTTraitTypes = "Crit Damage"
const NFTTraitTypesCritPoints NFTTraitTypes = "Crit Points"
const NFTTraitTypesDefence NFTTraitTypes = "Defence"
const NFTTraitTypesDodgePoints NFTTraitTypes = "Dodge Points"
const NFTTraitTypesHPRecovery NFTTraitTypes = "HP Recovery"
const NFTTraitTypesHitPoints NFTTraitTypes = "Hit Points"
const NFTTraitTypesLearnRecipe NFTTraitTypes = "Learn Recipe"
const NFTTraitTypesMaxHP NFTTraitTypes = "MaxHP"
const NFTTraitTypesMoveSpeed NFTTraitTypes = "Move Speed"
const NFTTraitTypesPlaceableLands NFTTraitTypes = "Placeable Lands"
const NFTTraitTypesQuality NFTTraitTypes = "Quality"
const NFTTraitTypesRarity NFTTraitTypes = "Rarity"
const NFTTraitTypesRestoreHP NFTTraitTypes = "Restore HP"
const NFTTraitTypesSeries NFTTraitTypes = "Series"
const NFTTraitTypesSkillLevel NFTTraitTypes = "SkillLevel"
const NFTTraitTypesType NFTTraitTypes = "Type"
const NFTTraitTypesWearingPosition NFTTraitTypes = "Wearing Position"

type NFTTraitWearingPosition interface{}

type PageMeta struct {
	// Count corresponds to the JSON schema field "count".
	Count float64 `json:"count"`
}

type Sex string

const SexFEMALE Sex = "FEMALE"
const SexMALE Sex = "MALE"

type Sex_1 string

const Sex_1_FEMALE Sex_1 = "FEMALE"
const Sex_1_MALE Sex_1 = "MALE"

type Skill struct {
	// skill level
	Level Int322 `json:"level"`

	// skill Id,  only key
	SkillId Int322 `json:"skillId"`
}

type SubscriptionEvent string

const SubscriptionEventLandAttributionUpdate SubscriptionEvent = "LandAttributionUpdate"
const SubscriptionEventLandFightStatusUpdate SubscriptionEvent = "LandFightStatusUpdate"
const SubscriptionEventMultiLandAttributionUpdate SubscriptionEvent = "MultiLandAttributionUpdate"
const SubscriptionEventMultiUpdateUserNFT SubscriptionEvent = "MultiUpdateUserNFT"
const SubscriptionEventUpdateUserNFT SubscriptionEvent = "UpdateUserNFT"

type TemporaryToken struct {
	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt string `json:"createdAt"`

	// ExpiredAt corresponds to the JSON schema field "expiredAt".
	ExpiredAt string `json:"expiredAt"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// TemporaryTokenExtraInfo corresponds to the JSON schema field
	// "temporaryTokenExtraInfo".
	TemporaryTokenExtraInfo *TemporaryTokenExtraInfo `json:"temporaryTokenExtraInfo,omitempty"`

	// Token corresponds to the JSON schema field "token".
	Token string `json:"token"`

	// UpdatedAt corresponds to the JSON schema field "updatedAt".
	UpdatedAt string `json:"updatedAt"`

	// UsedAt corresponds to the JSON schema field "usedAt".
	UsedAt *string `json:"usedAt,omitempty"`
}

type TemporaryTokenExtraInfo struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

// 更新用户的NFT
// 可能是添加或者数量变更.
type UpdateUserNFT struct {
	// 消息版本号
	Etag Int321 `json:"etag"`

	// NFT信息
	Nft NFT `json:"nft"`

	// 归属用户id
	UserId string `json:"userId"`
}

type User struct {
	// Avatar corresponds to the JSON schema field "avatar".
	Avatar string `json:"avatar"`

	// Email corresponds to the JSON schema field "email".
	Email string `json:"email"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Mobile corresponds to the JSON schema field "mobile".
	Mobile string `json:"mobile"`

	// Nickname corresponds to the JSON schema field "nickname".
	Nickname string `json:"nickname"`

	// Realname corresponds to the JSON schema field "realname".
	Realname string `json:"realname"`

	// SchoolId corresponds to the JSON schema field "schoolId".
	SchoolId string `json:"schoolId"`

	// Sex corresponds to the JSON schema field "sex".
	Sex Sex_1 `json:"sex"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username"`

	// Usertype corresponds to the JSON schema field "usertype".
	Usertype UserType `json:"usertype"`
}

type UserGameDataInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId"`
}

type UserGameDataOutput struct {
	// game name
	Name string `json:"name"`

	// 游戏角色ID
	PlayerId string `json:"playerId"`

	// user id
	UserId string `json:"userId"`
}

// 玩家地格信息数据结构
type UserLandInfo struct {
	// 攻占的地格
	OccupiedLands []Int32 `json:"occupiedLands"`

	// 门票地格
	TicketLands []Int32 `json:"ticketLands"`

	// 购买的地格
	VipLands []Int32 `json:"vipLands"`
}

type UserType string

const UserTypeMANAGER UserType = "MANAGER"
const UserTypeSTUDENT UserType = "STUDENT"
const UserTypeTEACHER UserType = "TEACHER"

type UserType_1 string

const UserType_1_MANAGER UserType_1 = "MANAGER"
const UserType_1_STUDENT UserType_1 = "STUDENT"
const UserType_1_TEACHER UserType_1 = "TEACHER"

type Web3ServiceAction string

const Web3ServiceActionBatchMintNFTWithItemId Web3ServiceAction = "BatchMintNFTWithItemId"
const Web3ServiceActionGetUserRecipes Web3ServiceAction = "GetUserRecipes"
const Web3ServiceActionMergeByRecipe Web3ServiceAction = "MergeByRecipe"
const Web3ServiceActionMintNFTWithItemId Web3ServiceAction = "MintNFTWithItemId"
const Web3ServiceActionMintNFTWithMetadata Web3ServiceAction = "MintNFTWithMetadata"

var enumValues_AppId = []interface{}{
	"bellplanet-game",
	"meland-service",
	"web3-service",
}
var enumValues_AuthUserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_GameServiceAction = []interface{}{
	"LandUsingSkill",
}
var enumValues_LandFightStatus = []interface{}{
	"attacked",
	"normal",
}
var enumValues_LandFightStatus_1 = []interface{}{
	"attacked",
	"normal",
}
var enumValues_LandStatus = []interface{}{
	"nill",
	"occupied",
	"ticket",
	"unoccupied",
	"vip",
}
var enumValues_LandStatus_1 = []interface{}{
	"nill",
	"occupied",
	"ticket",
	"unoccupied",
	"vip",
}
var enumValues_MelandServiceAction = []interface{}{
	"BurnDitamin",
	"CanBuildNFT",
	"GetInitLandAttributions",
	"GetUserNFTs",
	"GetUserWeb3Profile",
}
var enumValues_NFTTraitPlaceableLands = []interface{}{
	"Occupied",
	"Ticket",
	"VIP",
}
var enumValues_NFTTraitQuality = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}
var enumValues_NFTTraitRarity = []interface{}{
	"common",
	"epic",
	"mythic",
	"rare",
	"unique",
}
var enumValues_NFTTraitType = []interface{}{
	"Bow",
	"Chest Armor",
	"Consumable",
	"Dagger",
	"Feet Armor",
	"Hands Armor",
	"Head Armor",
	"Legs Armor",
	"Material",
	"MysteryBox",
	"Placeable",
	"Spear",
	"Sword",
}
var enumValues_NFTTraitTypes = []interface{}{
	"Attack",
	"Attack Speed",
	"CoreSkillId",
	"Crit Damage",
	"Crit Points",
	"Defence",
	"Dodge Points",
	"HP Recovery",
	"Hit Points",
	"Learn Recipe",
	"MaxHP",
	"Move Speed",
	"Placeable Lands",
	"Quality",
	"Rarity",
	"Restore HP",
	"Series",
	"SkillLevel",
	"Type",
	"Wearing Position",
}
var enumValues_Sex = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_Sex_1 = []interface{}{
	"FEMALE",
	"MALE",
}
var enumValues_SubscriptionEvent = []interface{}{
	"LandAttributionUpdate",
	"LandFightStatusUpdate",
	"MultiLandAttributionUpdate",
	"MultiUpdateUserNFT",
	"UpdateUserNFT",
}
var enumValues_UserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_UserType_1 = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}
var enumValues_Web3ServiceAction = []interface{}{
	"BatchMintNFTWithItemId",
	"GetUserRecipes",
	"MergeByRecipe",
	"MintNFTWithItemId",
	"MintNFTWithMetadata",
}
